import { EventInternals } from "./event";
import { EVENT } from "./constants";
export declare namespace LightRemapperInternals {
    class BaseLightRemapper {
        protected startType: EVENT;
        protected endType: EVENT;
        protected range: number[];
        protected startMap: number[] | number[][] | boolean;
        protected endMap: number | number[] | (number | number[])[];
        protected mulColor: number[];
        /**
         * Class mainly focused on remapping lightIDs for events.
         * @param {Number} startType
         * @param {Number | Array} range Range a lightID needs to fit in, in order to pass
         */
        constructor(startType: EVENT, range?: number | number[]);
        /**
         * Set the entry conditions for each event.
         * @param {Number} type
         * @param {Number | Array} range Range a lightID needs to fit in, in order to pass
         * @returns
         */
        conditions(type: number, range: number | number[]): this;
        /**
         * Sets the type of the event.
         * @param {Number} type
         * @returns
         */
        setType(type: EVENT): this;
        /**
         * Multiplies the colors of the event. Applies to gradients too.
         * @param {Number} rgb
         * @param {Number} alpha
         * @returns
         */
        multiplyColor(rgb: number, alpha?: number): this;
        /**
         * Test the algorithm with some lightIDs which will be logged.
         * @param {Array} ids
         */
        test(ids: number[]): void;
        /**
         * Run the algorithm.
         * @param {Boolean} log Log the output JSON of each event.
         * @param {Function} forLights Lambda function for each event.
         */
        run(log?: boolean, forLights?: (event: EventInternals.AbstractEvent) => void): void;
        protected set setRange(value: number | number[]);
        protected doProcess(test: number[] | boolean, forLights?: (event: EventInternals.AbstractEvent) => void): void;
    }
    class LightOverrider extends BaseLightRemapper {
        constructor(startType: number, endType: number, range: number[], lightID: number | number[], mulColor: number[]);
    }
}
export declare class LightRemapper extends LightRemapperInternals.BaseLightRemapper {
    /**
     * Sets the lightID of the event.
     * Removes some (now redundant) functions.
     * @param {Number | Array} lightID
     * @returns
     */
    setLightID(lightID: number | number[]): LightRemapperInternals.LightOverrider;
    /**
     * Normalizes a sequence of lightIDs to a sequence of: 1, 2, 3, 4, 5... etc.
     * @param {Number} start Start of the sequence.
     * @param {Number} step Differences between lightIDs.
     * @returns
     */
    normalizeLinear(start: number, step: number): this;
    /**
     * Normalizes a sequence of lightIDs to a sequence of: 1, 2, 3, 4, 5... etc.
     * Accounts for differences changing at different points.
     * @param {Array} map [[start, step], [start, step]...]
     *
     * start - The point at which the differences change.
     *
     * step - The new differences.
     *
     * If the sequence goes: 1, 3, 5, 6, 7, the differences change from 2 to 1 at the third number.
     * So map would look like: [[1, 2], [3, 1]]
     * @returns
     */
    normalizeWithChanges(map: number[][]): this;
    /**
     * Effects the ending sequence of lightIDs.
     * @param {Number} offset Add a number to each lightID.
     * @param {Number} step Changes the differences between each lightID.
     * @returns
     */
    addToEnd(offset: number, step?: number): this;
    /**
     * Remap lightIDs assuming the output is a sequence of 1, 2, 3, 4, 5...
     * @param {Array} map Works like map in normalizeWithChanges() but in reverse.
     * @param {Number} offset Adds a number to each lightID.
     * @returns
     */
    remapEnd(map: number[][], offset?: number): this;
}
