import { KeyframesVec3 } from './animation';
import { Wall } from './wall';
import { EASE } from './constants';
import { Note } from './note';
import { EventInternals } from './event';
export declare type Vec3 = [number, number, number];
export declare type Vec4 = [number, number, number, number];
export declare type ColorType = [number, number, number] | [number, number, number, number];
/**
 * Allows you to filter through an array of objects with a min and max property.
 * @param {Number} min
 * @param {Number} max
 * @param {Array} objects Array of objects to check.
 * @param {String} property What property to check for.
 * @returns {Array}
 */
export declare function filterObjects(objects: object[], min: number, max: number, property: string): any[];
/**
 * Sorts an array of objects by a property.
 * @param {Array} objects Array of objects to sort.
 * @param {String} property What property to sort.
 * @param {Boolean} smallestToLargest Whether to sort smallest to largest. True by default.
 */
export declare function sortObjects(objects: object[], property: string, smallestToLargest?: boolean): void;
/**
 * Gets notes between a min and max time, as a Note class.
 * @param {Number} min
 * @param {Number} max
 * @param {Function} forEach Lambda function for each note.
 * @returns {Array}
 */
export declare function notesBetween(min: number, max: number, forEach: (note: Note) => void): void;
/**
 * Gets walls between a min and max time, as a Wall class.
 * @param {Number} min
 * @param {Number} max
 * @param {Function} forEach Lambda function for each wall.
 * @returns {Array}
 */
export declare function wallsBetween(min: number, max: number, forEach: (note: Wall) => void): void;
/**
 * Gets events between a min and max time, as an Event class.
 * @param {Number} min
 * @param {Number} max
 * @param {Function} forEach Lambda function for each event.
 * @returns {Array}
 */
export declare function eventsBetween(min: number, max: number, forEach: (note: EventInternals.AbstractEvent) => void): void;
/**
 * Interpolates between a start and end value to get a value in between.
 * @param {Number} start
 * @param {Number} end
 * @param {Number} fraction
 * @param {String} easing Optional easing
 * @returns {Number}
 */
export declare function lerp(start: number, end: number, fraction: number, easing?: EASE): number;
/**
 * Interpolates between a start and end value to get a value in between. Will wrap around 0-1.
 * @param {Number} start
 * @param {Number} end
 * @param {Number} fraction
 * @param {String} easing Optional easing
 * @returns
 */
export declare function lerpWrap(start: number, end: number, fraction: number, easing?: EASE): number;
/**
 * Interpolates between a start and end rotation to get a rotation in between.
 * @param {Vec3} start
 * @param {Vec3} end
 * @param {Number} fraction
 * @param {EASE} easing
 * @returns
 */
export declare function lerpRotation(start: Vec3, end: Vec3, fraction: number, easing?: EASE): Vec3;
/**
 * Process a number through an easing.
 * @param {String} easing Name of easing.
 * @param {Number} value Progress of easing (0-1).
 * @returns {Number}
 */
export declare function lerpEasing(easing: EASE, value: number): number;
/**
 * Find value between 0 and 1 from a beginning, length, and a point in time between.
 * @param {Number} beginning
 * @param {Number} length
 * @param {Number} time
 * @returns {Number}
 */
export declare function findFraction(beginning: number, length: number, time: number): number;
/**
 * Get the last element in an array.
 * @param {Array} arr
 * @returns {*}
 */
export declare function arrLast(arr: any[]): any;
/**
 * Add either a number or another array to an array.
 * @param {Array} arr
 * @param {*} value Can be a number or an array.
 * @returns {Array}
 */
export declare function arrAdd(arr: number[], value: number[] | number): number[];
/**
 * Multiply an array either by a number or another array.
 * @param {Array} arr
 * @param {*} value Can be a number or an array.
 * @returns {Array}
 */
export declare function arrMul(arr: number[], value: number[] | number): number[];
/**
 * Divide an array either by a number or another array.
 * @param {Array} arr
 * @param {*} value Can be a number or an array.
 * @returns {Array}
 */
export declare function arrDiv(arr: number[], value: number[] | number): number[];
/**
 * Check if 2 arrays are equal to each other.
 * @param {Array} arr1
 * @param {Array} arr2
 * @param {Number} lenience The maximum difference 2 numbers in an array can have before they're considered not equal.
 * @returns {Boolean}
 */
export declare function arrEqual(arr1: number[], arr2: number[], lenience?: number): boolean;
/**
 * Gives a random number in the given range.
 * @param {Number} start
 * @param {Number} end
 * @returns {Number}
 */
export declare function rand(start: number, end: number): number;
/**
 * Rounds a number to the nearest other number.
 * @param {Number} input
 * @param {Number} number
 * @returns {Number}
 */
export declare function round(input: number, number: number): number;
/**
 * Makes a number fit between a min and max value.
 * @param {Number} input
 * @param {Number} min Can be left undefined to ignore.
 * @param {Number} max Can be left undefined to ignore.
 * @returns {Number}
 */
export declare function clamp(input: number, min?: number, max?: number): number;
/**
 * Creates a new instance of an object.
 * @param {*} obj
 * @returns
 */
export declare function copy<T>(obj: T): T;
/**
 * Checks if an object is empty.
 * @param {Object} o
 * @returns {Boolean}
 */
export declare function isEmptyObject(o: object): boolean;
/**
 * Rotate a point around 0,0,0.
 * @param {Array} rotation
 * @param {Array} point
 * @param {Array} anchor Anchor of rotation.
 * @returns {Array}
 */
export declare function rotatePoint(rotation: Vec3, point: Vec3, anchor?: Vec3): Vec3;
/**
 * Rotate a vector, starts downwards.
 * @param {Array} rotation
 * @param {Number} length
 * @returns {Array}
 */
export declare function rotateVector(rotation: Vec3, length: number): Vec3;
/**
 * Convert an array of numbers from degrees to radians.
 * @param {Array} values
 * @returns
 */
export declare function toRadians(values: number[]): number[];
/**
 * Convert an array of numbers from radians to degrees.
 * @param {Array} values
 * @returns
 */
export declare function toDegrees(values: number[]): number[];
/**
 * Delete empty objects/arrays from an object recursively.
 * @param {Object} obj
 */
export declare function jsonPrune(obj: object): void;
/**
* Get a property of an object.
* @param {Object} obj
* @param {String} prop
* @param {Any?} init Optional value to initialize the property if it doesn't exist yet.
*/
export declare function jsonGet(obj: object, prop: string, init?: any): any;
/**
* Fill the object with empty properties along the path of prop.
* @param {Object} obj
* @param {String} prop
* @param {Any} value
*/
export declare function jsonFill(obj: object, prop: string, value: any): void;
/**
 * Set a property in an object, add objects if needed.
 * @param {Object} obj
 * @param {String} prop
 * @param {*} value
 */
export declare function jsonSet(obj: object, prop: string, value: any): void;
/**
 * Check if a property in an object exists
 * @param {Object} obj
 * @param {String} prop
 * @returns {Boolean}
 */
export declare function jsonCheck(obj: object, prop: string): boolean;
/**
* Remove a property of an object recursively, and delete empty objects left behind.
* @param {Object} obj
* @param {String} prop
*/
export declare function jsonRemove(obj: object, prop: string): void;
/**
 * Get jump related info.
 * @param {Number} NJS
 * @param {Number} offset
 * @param {Number} BPM
 * @returns {Object} Returns an object; {halfDur, dist}.
 * A "jump" is the period when the object "jumps" in (indicated by spawning light on notes) to when it's deleted.
 * Jump Duration is the time in beats that the object will be jumping for.
 * This function will output half of this, so it will end when the note is supposed to be hit.
 * Jump Distance is the Z distance from when the object starts it's jump to when it's deleted.
 * This function will output the jump distance converted to noodle units.
 */
export declare function getJumps(NJS: number, offset: number, BPM: number): {
    halfDur: number;
    dist: number;
};
/**
 * Calculate the correct position for a wall to line up with a position in the world.
 * @param {Array} pos
 * @param {Array} rot
 * @param {Array} scale
 * @returns
 */
export declare function worldToWall(pos: Vec3, rot: Vec3, scale: Vec3): Vec3;
/**
 * Create a wall for debugging. Position, rotation, and scale are in world space and can be animations.
 * @param {Array} pos
 * @param {Array} rot
 * @param {Array} scale
 * @param {Number} animStart When animation starts.
 * @param {Number} animDur How long animation lasts for.
 * @param {Number} animFreq Frequency of keyframes in animation.
 */
export declare function debugWall(pos?: KeyframesVec3, rot?: KeyframesVec3, scale?: KeyframesVec3, animStart?: number, animDur?: number, animFreq?: number): void;
