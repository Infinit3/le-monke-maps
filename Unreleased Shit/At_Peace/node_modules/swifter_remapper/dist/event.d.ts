import { EASE, EVENT } from './constants';
import { ColorType } from './general';
export declare namespace EventInternals {
    class BaseEvent {
        json: any;
        constructor(time: number | object);
        /**
        * Push this event to the difficulty
        */
        push(): this;
        get time(): number;
        get type(): number;
        get value(): number;
        get floatValue(): number;
        get customData(): any;
        set time(value: number);
        set type(value: number);
        set value(value: number);
        set floatValue(value: number);
        set customData(value: any);
        get isModded(): boolean;
    }
    class LightEvent extends EventInternals.BaseEvent {
        constructor(json: object, type: EVENT);
        /**
         * Create an event that turns lights off.
         * @returns
         */
        off(): this;
        /**
         * Create an event that turns lights on.
         * @param {Array} color Can be boolean to determine if the light is blue (true), or a color.
         * @param {Number | Array} lightID
         * @returns
         */
        on(color: ColorType | boolean, lightID?: number | number[]): this;
        /**
         * Create an event that flashes the lights.
         * @param {Array} color Can be boolean to determine if the light is blue (true), or a color.
         * @param {Number | Array} lightID
         * @returns
         */
        flash(color: ColorType | boolean, lightID?: number | number[]): this;
        /**
         * Create an event that fades the lights out.
         * @param {Array} color Can be boolean to determine if the light is blue (true), or a color.
         * @param {Number | Array} lightID
         * @returns
         */
        fade(color: ColorType | boolean, lightID?: number | number[]): this;
        /**
         * Create an event that makes the lights fade in to this color from the previous.
         * @param {Array} color Can be boolean to determine if the light is blue (true), or a color.
         * @param {Number | Array} lightID
         * @returns
         */
        in(color: ColorType | boolean, lightID?: number | number[]): this;
        /**
         * Create a light gradient between 2 colors. This feature is deprecated in Chroma.
         * @param {Array} startColor
         * @param {Array} endColor
         * @param {Number} duration
         * @param {String} easing
         * @returns
         */
        gradient(startColor: ColorType, endColor: ColorType, duration: number, easing?: EASE): this;
        /**
        * Remove the subclass of the event, giving access to all properties, but can allow for invalid data.
        * @returns {AbstractEvent}
        */
        abstract(): AbstractEvent;
        get lightID(): number | number[];
        get color(): ColorType;
        get easing(): EASE;
        get lerpType(): string;
        get lightGradient(): any;
        get startColor(): ColorType;
        get endColor(): ColorType;
        get duration(): number;
        get gradientEasing(): EASE;
        set lightID(value: number | number[]);
        set color(value: ColorType);
        set easing(value: EASE);
        set lerpType(value: string);
        set lightGradient(value: any);
        set startColor(value: ColorType);
        set endColor(value: ColorType);
        set duration(value: number);
        set gradientEasing(value: EASE);
    }
    class LaserSpeedEvent extends EventInternals.BaseEvent {
        constructor(json: object, type: EVENT, speed: number, direction?: number, lockPosition?: boolean);
        /**
        * Remove the subclass of the event, giving access to all properties, but can allow for invalid data.
        * @returns {AbstractEvent}
        */
        abstract(): AbstractEvent;
        get lockPosition(): boolean;
        get speed(): number;
        get direction(): number;
        set lockPosition(value: boolean);
        set speed(value: number);
        set direction(value: number);
    }
    class RingZoomEvent extends EventInternals.BaseEvent {
        constructor(json: object, step?: number, speed?: number);
        /**
        * Remove the subclass of the event, giving access to all properties, but can allow for invalid data.
        * @returns {AbstractEvent}
        */
        abstract(): AbstractEvent;
        get step(): number;
        get speed(): number;
        set step(value: number);
        set speed(value: number);
    }
    class RingSpinEvent extends EventInternals.BaseEvent {
        constructor(json: object, rotation?: number, direction?: number, step?: number, speed?: number, prop?: number, reset?: boolean, nameFilter?: string, counterSpin?: boolean);
        /**
        * Remove the subclass of the event, giving access to all properties, but can allow for invalid data.
        * @returns {AbstractEvent}
        */
        abstract(): AbstractEvent;
        get speed(): number;
        get direction(): number;
        get nameFilter(): string;
        get reset(): boolean;
        get rotation(): number;
        get step(): number;
        get prop(): number;
        get counterSpin(): boolean;
        set speed(value: number);
        set direction(value: number);
        set nameFilter(value: string);
        set reset(value: boolean);
        set rotation(value: number);
        set step(value: number);
        set prop(value: number);
        set counterSpin(value: boolean);
    }
    class RotationEvent extends EventInternals.BaseEvent {
        constructor(json: object, type: EVENT, rotation?: number);
        /**
        * Remove the subclass of the event, giving access to all properties, but can allow for invalid data.
        * @returns {AbstractEvent}
        */
        abstract(): AbstractEvent;
        get rotation(): any;
        set rotation(value: any);
    }
    class AbstractEvent extends EventInternals.BaseEvent {
        get lockPosition(): boolean;
        get lightID(): number | number[];
        get color(): ColorType;
        get easing(): EASE;
        get lerpType(): string;
        get lightGradient(): any;
        get startColor(): ColorType;
        get endColor(): ColorType;
        get duration(): number;
        get gradientEasing(): EASE;
        get speed(): number;
        get direction(): number;
        get nameFilter(): string;
        get reset(): boolean;
        get rotation(): number;
        get step(): number;
        get prop(): number;
        get counterSpin(): boolean;
        set lockPosition(value: boolean);
        set speed(value: number);
        set direction(value: number);
        set nameFilter(value: string);
        set reset(value: boolean);
        set rotation(value: number);
        set step(value: number);
        set prop(value: number);
        set counterSpin(value: boolean);
        set lightID(value: number | number[]);
        set color(value: ColorType);
        set easing(value: EASE);
        set lerpType(value: string);
        set lightGradient(value: any);
        set startColor(value: ColorType);
        set endColor(value: ColorType);
        set duration(value: number);
        set gradientEasing(value: EASE);
    }
}
export declare class Event extends EventInternals.BaseEvent {
    /**
     * Event object for ease of creation.
     * @param {Object} time
     */
    constructor(time?: number);
    /**
     * Controls the back lasers.
     * @returns
     */
    backLasers(): EventInternals.LightEvent;
    /**
     * Controls the ring lights.
     * @returns
     */
    ringLights(): EventInternals.LightEvent;
    /**
     * Controls the left lasers.
     * @returns
     */
    leftLasers(): EventInternals.LightEvent;
    /**
     * Controls the right lasers.
     * @returns
     */
    rightLasers(): EventInternals.LightEvent;
    /**
     * Controls the center lasers.
     * @returns
     */
    centerLasers(): EventInternals.LightEvent;
    /**
     * Controls the extra left lasers in some environments.
     * @returns
     */
    extraLeft(): EventInternals.LightEvent;
    /**
     * Controls the extra right lasers in some environments.
     * @returns
     */
    extraRight(): EventInternals.LightEvent;
    /**
     * Controls the left lasers in the Billie environment.
     * @returns
     */
    billieLeft(): EventInternals.LightEvent;
    /**
     * Controls the right lasers in the Billie environment.
     * @returns
     */
    billieRight(): EventInternals.LightEvent;
    /**
     * Create an event using JSON.
     * @param {Object} json
     * @returns {AbstractEvent}
     */
    import(json: object): EventInternals.AbstractEvent;
    /**
     * Create an event with no particular identity.
    * @returns {AbstractEvent};
    */
    abstract(): EventInternals.AbstractEvent;
    /**
     * Make this event change boost colors.
     * @param {Boolean} on
     * @returns
     */
    boost(on: boolean): EventInternals.BaseEvent;
    /**
     * Move cars in the interscope environment.
     * @param {Number} value
     * @returns
     */
    moveCars(value: EVENT): EventInternals.BaseEvent;
    /**
     * Lower the hydraulics of the cars in the interscope environment.
     * @returns
     */
    lowerHydraulics(): EventInternals.BaseEvent;
    /**
     * Raise the hydraulics of the cars in the interscope environment.
     * @returns
     */
    raiseHydraulics(): EventInternals.BaseEvent;
    /**
     * Spin the rings in an environment.
     * @param {Number} rotation
     * @param {Number} direction
     * @param {Number} step
     * @param {Number} speed
     * @param {Number} prop
     * @param {Boolean} reset
     * @param {String} nameFilter
     * @param {Boolean} counterSpin
     * @returns
     */
    ringSpin(rotation?: number, direction?: number, step?: number, speed?: number, prop?: number, reset?: boolean, nameFilter?: string, counterSpin?: boolean): EventInternals.RingSpinEvent;
    /**
     * Control the zoom of the rings.
     * @param {Number} step
     * @param {Number} speed
     * @returns
     */
    ringZoom(step?: number, speed?: number): EventInternals.RingZoomEvent;
    /**
     * Control the movement speed of the left lasers.
     * @param {Number} speed When containing decimals, the noodle data will be used for speed.
     * @param {Number} direction
     * @param {Boolean} lockPosition
     * @returns
     */
    leftLaserSpeed(speed: number, direction?: number, lockPosition?: boolean): EventInternals.LaserSpeedEvent;
    /**
     * Control the movement speed of the right lasers.
     * @param {Number} speed When containing decimals, the noodle data will be used for speed.
     * @param {Number} direction
     * @param {Boolean} lockPosition
     * @returns
     */
    rightLaserSpeed(speed: number, direction?: number, lockPosition?: boolean): EventInternals.LaserSpeedEvent;
    /**
     * Used for 360 mode, rotates future objects and active objects.
     * @param {Number} rotation
     * @returns
     */
    earlyRotation(rotation: EVENT): EventInternals.RotationEvent;
    /**
     * Used for 360 mode, rotates future objects only.
     * @param {Number} rotation
     * @returns
     */
    lateRotation(rotation: EVENT): EventInternals.RotationEvent;
}
