"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.animateEnvTrack = exports.animateEnvGroup = exports.BlenderEnvironment = exports.BlenderEnvironmentInternals = exports.Environment = void 0;
const animation_1 = require("./animation");
const beatmap_1 = require("./beatmap");
const general_1 = require("./general");
const custom_event_1 = require("./custom_event");
const constants_1 = require("./constants");
const anim_optimizer_1 = require("./anim_optimizer");
let envCount = 0;
let blenderEnvCount = 0;
const trackData = [];
const debugData = [
    { _definitePosition: [[0, 1, 0, 0]], _localRotation: [[0, 0, 0, 0]], _scale: [[1, 1, 1, 0]] },
    { _definitePosition: [[4, 1, 0, 0]], _localRotation: [[45, 0, 0, 0]], _scale: [[1, 1, 1, 0]] },
    { _definitePosition: [[0, 5, 0, 0]], _localRotation: [[0, 45, 0, 0]], _scale: [[1, 1, 1, 0]] },
    { _definitePosition: [[0, 1, 4, 0]], _localRotation: [[0, 0, 45, 0]], _scale: [[1, 1, 1, 0]] }
];
class Environment {
    /**
     * Environment object for ease of creation and additional tools.
     * @param {String} id
     * @param {String} lookupMethod
     */
    constructor(id = undefined, lookupMethod = undefined) {
        this.json = {};
        id !== null && id !== void 0 ? id : (id = "");
        lookupMethod !== null && lookupMethod !== void 0 ? lookupMethod : (lookupMethod = constants_1.LOOKUP.CONTAINS);
        this.id = id;
        this.lookupMethod = lookupMethod;
    }
    /**
    * Create an environment object using JSON.
    * @param {Object} json
    * @returns {Environment}
    */
    import(json) {
        this.json = json;
        return this;
    }
    /**
     * Push this environment object to the difficulty
     */
    push() {
        if (this.track.value === undefined)
            this.trackSet = `environment${envCount}`;
        envCount++;
        if (beatmap_1.activeDiff.environment === undefined)
            beatmap_1.activeDiff.environment = [];
        beatmap_1.activeDiff.environment.push((0, general_1.copy)(this));
        return this;
    }
    get id() { return this.json._id; }
    get lookupMethod() { return this.json._lookupMethod; }
    get duplicate() { return this.json._duplicate; }
    get active() { return this.json._active; }
    get scale() { return this.json._scale; }
    get position() { return this.json._position; }
    get localPosition() { return this.json._localPosition; }
    get rotation() { return this.json._rotation; }
    get localRotation() { return this.json._localRotation; }
    get lightID() { return this.json._lightID; }
    get track() { return new animation_1.Track(this.json._track); }
    get group() { return this.json._group; }
    get animationProperties() {
        const returnObj = {};
        if (this.position !== undefined)
            returnObj._position = this.position;
        if (this.localPosition !== undefined)
            returnObj._localPosition = this.localPosition;
        if (this.rotation !== undefined)
            returnObj._rotation = this.rotation;
        if (this.localRotation !== undefined)
            returnObj._localRotation = this.localRotation;
        if (this.scale !== undefined)
            returnObj._scale = this.scale;
        return returnObj;
    }
    set id(value) { this.json._id = value; }
    set lookupMethod(value) { this.json._lookupMethod = value; }
    set duplicate(value) { this.json._duplicate = value; }
    set active(value) { this.json._active = value; }
    set scale(value) { this.json._scale = value; }
    set position(value) { this.json._position = value; }
    set localPosition(value) { this.json._localPosition = value; }
    set rotation(value) { this.json._rotation = value; }
    set localRotation(value) { this.json._localRotation = value; }
    set lightID(value) { this.json._lightID = value; }
    set trackSet(value) { this.json._track = value; }
    set group(value) { this.json._group = value; }
}
exports.Environment = Environment;
const blenderShrink = 9 / 10; // For whatever reason.. this needs to be multiplied to all of the scales to make things look proper... who knows man.
var BlenderEnvironmentInternals;
(function (BlenderEnvironmentInternals) {
    class BaseBlenderEnvironment {
        constructor(scale, anchor) {
            this.scale = scale.map(x => (1 / x) / 0.6);
            this.anchor = anchor;
        }
        processData(trackData) {
            const outputData = [];
            if (typeof trackData === "string")
                trackData = getTrackData(trackData);
            trackData.forEach(x => {
                const data = {
                    rawPos: [],
                    rawScale: [],
                    pos: [],
                    rot: [],
                    scale: []
                };
                const posData = x._definitePosition;
                const rotData = x._localRotation;
                const scaleData = x._scale;
                let longestArr = [];
                const length = Math.max(posData.length, rotData.length, scaleData.length);
                if (posData.length === length)
                    longestArr = posData;
                if (rotData.length === length)
                    longestArr = rotData;
                if (scaleData.length === length)
                    longestArr = scaleData;
                let posIndex = 0;
                let rotIndex = 0;
                let scaleIndex = 0;
                for (let i = 0; i < length; i++) {
                    let pos = new animation_1.Keyframe(posData[posIndex]);
                    let rot = new animation_1.Keyframe(rotData[rotIndex]);
                    let scale = new animation_1.Keyframe(scaleData[scaleIndex]);
                    const ref = new animation_1.Keyframe(longestArr[i]);
                    posIndex++;
                    rotIndex++;
                    scaleIndex++;
                    if (pos.time !== ref.time) {
                        posIndex--;
                        pos = new animation_1.Keyframe(posData[posIndex]);
                    }
                    if (rot.time !== ref.time) {
                        rotIndex--;
                        rot = new animation_1.Keyframe(rotData[rotIndex]);
                    }
                    else
                        data.rot.push(rot.data);
                    if (scale.time !== ref.time) {
                        scaleIndex--;
                        scale = new animation_1.Keyframe(scaleData[scaleIndex]);
                    }
                    else {
                        data.rawScale.push([...scale.values.map(y => y * blenderShrink), ref.time]);
                        data.scale.push([...scale.values.map((y, i) => y * this.scale[i] * blenderShrink), ref.time]);
                    }
                    const objPos = pos.values;
                    const objRot = rot.values;
                    const objScale = scale.values;
                    data.rawPos.push([...objPos, ref.time]);
                    const offset = (0, general_1.rotatePoint)(objRot, objScale.map((y, i) => y * -this.anchor[i] * blenderShrink));
                    data.pos.push([...objPos.map((y, i) => y + offset[i]), ref.time]);
                }
                outputData.push(data);
            });
            return outputData;
        }
    }
    BlenderEnvironmentInternals.BaseBlenderEnvironment = BaseBlenderEnvironment;
    class BlenderAssigned extends BaseBlenderEnvironment {
        constructor(parent, scale, anchor, track, disappearWhenAbsent) {
            super(scale, anchor);
            this.parent = parent;
            this.track = track;
            this.disappearWhenAbsent = disappearWhenAbsent;
        }
        getDataForTrack(dataTrack) {
            return this.processData(`${dataTrack}_${this.track}`);
        }
        static(dataTrack, forEvents = undefined) {
            const data = this.getDataForTrack(dataTrack);
            if (data.length > 0) {
                const x = data[0];
                const objPos = [x.pos[0][0], x.pos[0][1], x.pos[0][2]];
                const objRot = [x.rot[0][0], x.rot[0][1], x.rot[0][2]];
                const objScale = [x.scale[0][0], x.scale[0][1], x.scale[0][2]];
                const moveEvent = new custom_event_1.CustomEvent().animateTrack(this.track);
                moveEvent.animate.position = objPos;
                moveEvent.animate.rotation = objRot;
                moveEvent.animate.scale = objScale;
                if (forEvents !== undefined)
                    forEvents(moveEvent);
                moveEvent.push();
            }
        }
        animate(dataTrack, time, duration, forEvents = undefined) {
            const data = this.getDataForTrack(dataTrack);
            if (data.length > 0) {
                const x = data[0];
                const moveEvent = new custom_event_1.CustomEvent(time).animateTrack(this.track);
                moveEvent.animate.position = x.pos;
                moveEvent.animate.rotation = x.rot;
                moveEvent.animate.scale = x.scale;
                if (this.parent.assignedOptimizeSettings)
                    moveEvent.animate.optimize(undefined, this.parent.assignedOptimizeSettings);
                moveEvent.duration = duration;
                if (forEvents !== undefined)
                    forEvents(moveEvent);
                moveEvent.push();
            }
            else if (this.disappearWhenAbsent) {
                const moveEvent = new custom_event_1.CustomEvent(time).animateTrack(this.track);
                moveEvent.animate.position = "yeet";
                moveEvent.push();
            }
        }
    }
    BlenderEnvironmentInternals.BlenderAssigned = BlenderAssigned;
})(BlenderEnvironmentInternals = exports.BlenderEnvironmentInternals || (exports.BlenderEnvironmentInternals = {}));
class BlenderEnvironment extends BlenderEnvironmentInternals.BaseBlenderEnvironment {
    /**
    * Tool for using model data from ScuffedWalls for environments.
    * @param {Array} scale The scale of the object relative to a noodle unit cube.
    * @param {Array} anchor The anchor point of rotation on the object, 1 = length of object on that axis.
    */
    constructor(scale, anchor, id = undefined, lookupMethod = undefined) {
        super(scale, anchor);
        this.assigned = [];
        this.objectAmounts = [];
        this.maxObjects = 0;
        this.optimizeSettings = new anim_optimizer_1.OptimizeSettings();
        this.assignedOptimizeSettings = new anim_optimizer_1.OptimizeSettings();
        this.id = id;
        this.lookupMethod = lookupMethod;
        this.trackID = blenderEnvCount;
        blenderEnvCount++;
    }
    /**
     * Assign pre-existing tracks to be animated with this environment.
     * For example if the current data track is "shore" and you assign an object with track "cloud", there needs to be data for the track "shore_cloud".
     * In your shore model if you set the second material name to shore_cloud, you can move represent the cloud's transform by that object.
     * @param {Array} tracks Can be a single track or array of tracks.
     * @param {Vec3} scale
     * @param {Vec3} anchor
     * @param {Boolean} disappearWhenAbsent Determine whether to make this object disappear when no data for it is present in an environment.
     */
    assignObjects(tracks, scale = undefined, anchor = undefined, disappearWhenAbsent = true) {
        scale !== null && scale !== void 0 ? scale : (scale = [1, 1, 1]);
        anchor !== null && anchor !== void 0 ? anchor : (anchor = [0, 0, 0]);
        if (typeof tracks === "string")
            tracks = [tracks];
        tracks.forEach(x => { this.assigned.push(new BlenderEnvironmentInternals.BlenderAssigned(this, scale, anchor, x, disappearWhenAbsent)); });
    }
    /**
     * Look up the amount of objects active in the environment at a certain beat.
     * You'll want to do this after all of the environment switches (if any), so that the maximum can be properly calculated.
     * @param time
     */
    lookupAmount(time) {
        let result = 0;
        this.objectAmounts.forEach(x => {
            if (time >= x[0])
                result = x[1];
        });
        return result;
    }
    /**
     * Set the environment to be static. Should only be used once.
     * @param {String} dataTrack The track ScuffedWalls will output for this model's data.
     * If left undefined, a debug model with debug walls, useful for fitting objects to a cube, will be placed.
     * @param {Function} forEnv Runs for each environment object.
     * @param {Function} forAssigned Runs for each assigned object moving event.
     */
    static(dataTrack = undefined, forEnv = undefined, forAssigned = undefined) {
        let data;
        if (dataTrack === undefined)
            data = this.processData(debugData);
        else
            data = this.processData(dataTrack);
        let objects = 0;
        data.forEach(x => {
            const pos = [x.pos[0][0], x.pos[0][1], x.pos[0][2]];
            const rot = [x.rot[0][0], x.rot[0][1], x.rot[0][2]];
            const scale = [x.scale[0][0], x.scale[0][1], x.scale[0][2]];
            const envObject = new Environment(this.id, this.lookupMethod);
            envObject.position = pos;
            envObject.rotation = rot;
            envObject.scale = scale;
            envObject.duplicate = 1;
            objects++;
            if (forEnv !== undefined)
                forEnv(envObject, objects);
            envObject.push();
            if (dataTrack === undefined)
                (0, general_1.debugWall)([x.rawPos[0][0], x.rawPos[0][1], x.rawPos[0][2]], rot, [x.rawScale[0][0], x.rawScale[0][1], x.rawScale[0][2]]);
        });
        this.maxObjects = objects;
        this.objectAmounts = [[0, objects]];
        this.assigned.forEach(x => { x.static(dataTrack, forAssigned); });
    }
    /**
     * Set the environment to switch to different models at certain times. Also uses model animations.
     * @param {Array} switches First element is the data track of the switch, second element is the time,
     * third element (optional) is the duration of the animation.
     * fourth element (optional) is a function to run per environment moving event.
     * fifth element (optional) is a function to run per assigned object moving event.
     * @param {Function} forEnvSpawn function to run for each initial environment object.
     */
    animate(switches, forEnvSpawn = undefined) {
        createYeetDef();
        switches.sort((a, b) => a[1] - b[1]);
        switches.forEach(x => {
            var _a;
            const dataTrack = x[0];
            const time = x[1];
            const duration = (_a = x[2]) !== null && _a !== void 0 ? _a : 0;
            const forEnv = x[3];
            const forAssigned = x[4];
            const data = this.processData(dataTrack);
            let objects = 0;
            data.forEach((x, i) => {
                const event = new custom_event_1.CustomEvent(time).animateTrack(this.getPieceTrack(i), duration);
                event.animate.position = x.pos;
                event.animate.rotation = x.rot;
                event.animate.scale = x.scale;
                if (this.optimizeSettings)
                    event.animate.optimize(undefined, this.optimizeSettings);
                if (forEnv !== undefined)
                    forEnv(event, objects);
                event.push();
                objects++;
            });
            if (objects > this.maxObjects)
                this.maxObjects = objects;
            this.objectAmounts.push([time, objects]);
            this.assigned.forEach(x => { x.animate(dataTrack, time, duration, forAssigned); });
        });
        switches.forEach(x => {
            const time = x[1];
            const objects = this.lookupAmount(time);
            for (let i = objects; i < this.maxObjects; i++) {
                const event = new custom_event_1.CustomEvent(time).animateTrack(this.getPieceTrack(i));
                event.animate.position = "yeet";
                event.push();
            }
        });
        for (let i = 0; i < this.maxObjects; i++) {
            const envObject = new Environment(this.id, this.lookupMethod);
            envObject.position = [0, -69420, 0];
            envObject.duplicate = 1;
            envObject.trackSet = this.getPieceTrack(i);
            if (forEnvSpawn !== undefined)
                forEnvSpawn(envObject);
            envObject.push();
        }
    }
    /**
     * Get the track for a piece of the environment, if it's been animated.
     * @param {Number} index
     * @returns {Number}
     */
    getPieceTrack(index) {
        return `blenderEnv${this.trackID}_${index}`;
    }
}
exports.BlenderEnvironment = BlenderEnvironment;
/**
 * Animate each environment piece in a given assigned group, with all of their individual transforms combined.
 * @param {String} group
 * @param {Number} time
 * @param {Number} duration
 * @param {Object} animation
 * @param {String} easing
 */
function animateEnvGroup(group, time, duration, animation, easing = undefined) {
    if (beatmap_1.activeDiff.environment !== undefined)
        beatmap_1.activeDiff.environment.forEach(x => {
            if (x.group === group) {
                const newAnimation = (0, general_1.copy)(animation.json);
                Object.keys(newAnimation).forEach(key => {
                    if (x.json[key])
                        newAnimation[key] = (0, animation_1.combineAnimations)(newAnimation[key], x.json[key], key);
                });
                new custom_event_1.CustomEvent(time).animateTrack(x.track.value, duration, newAnimation, easing).push();
            }
        });
}
exports.animateEnvGroup = animateEnvGroup;
/**
 * Animate an environment piece with a track, with all of it's initial transforms combined.
 * @param {String} group
 * @param {Number} time
 * @param {Number} duration
 * @param {Object} animation
 * @param {String} easing
 */
function animateEnvTrack(track, time, duration, animation, easing = undefined) {
    if (beatmap_1.activeDiff.environment !== undefined)
        beatmap_1.activeDiff.environment.forEach(x => {
            if (x.track.has(track)) {
                const newAnimation = (0, general_1.copy)(animation.json);
                Object.keys(newAnimation).forEach(key => {
                    if (x.json[key])
                        newAnimation[key] = (0, animation_1.combineAnimations)(newAnimation[key], x.json[key], key);
                });
                new custom_event_1.CustomEvent(time).animateTrack(track, duration, newAnimation, easing).push();
            }
        });
}
exports.animateEnvTrack = animateEnvTrack;
function getTrackData(track) {
    if (!trackData[track]) {
        trackData[track] = [];
        for (let i = 0; i < beatmap_1.activeDiff.notes.length; i++) {
            const note = beatmap_1.activeDiff.notes[i];
            if (note.track.has(track)) {
                trackData[track].push(note.animation);
                beatmap_1.activeDiff.notes.splice(i, 1);
                i--;
            }
        }
    }
    return trackData[track];
}
let noYeet = true;
function createYeetDef() {
    if (noYeet === true) {
        noYeet = false;
        (0, animation_1.toPointDef)([0, -69420, 0], "yeet");
    }
}
