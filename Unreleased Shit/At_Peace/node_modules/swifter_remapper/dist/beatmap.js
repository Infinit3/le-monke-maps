"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transferVisuals = exports.exportZip = exports.forceJumpsForNoodleSet = exports.activeDiffSet = exports.forceJumpsForNoodle = exports.activeDiff = exports.info = exports.Info = exports.Difficulty = void 0;
const path_1 = __importDefault(require("path"));
const node_7z_1 = __importDefault(require("node-7z"));
const _7zip_bin_1 = __importDefault(require("7zip-bin"));
const fs = __importStar(require("fs"));
const note_1 = require("./note");
const wall_1 = require("./wall");
const event_1 = require("./event");
const custom_event_1 = require("./custom_event");
const environment_1 = require("./environment");
const general_1 = require("./general");
const anim_optimizer_1 = require("./anim_optimizer");
class Difficulty {
    /**
     * Creates a difficulty. Can be used to access various information and the map data.
     * Will set the active difficulty to this.
     * @param {String} input Filename for the input.
     * @param {String} input Filename for the output. If left blank, input will be used.
     */
    constructor(input, output = undefined) {
        // If the path contains a separator of any kind, use it instead of the default "Info.dat"
        exports.info.load((input.includes('\\') || input.includes('/')) ? path_1.default.join(path_1.default.dirname(input), "Info.dat") : undefined);
        this.mapFile = input;
        this.relativeMapFile = path_1.default.parse(output !== null && output !== void 0 ? output : input).base;
        if (output !== undefined) {
            if (!fs.existsSync(output))
                throw new Error(`The file ${output} does not exist`);
            this.mapFile = output;
        }
        if (!fs.existsSync(input))
            throw new Error(`The file ${input} does not exist`);
        this.json = JSON.parse(fs.readFileSync(input, "utf-8"));
        exports.info.json._difficultyBeatmapSets.forEach(set => {
            set._difficultyBeatmaps.forEach(setmap => {
                if (this.relativeMapFile === setmap._beatmapFilename) {
                    this.diffSet = set;
                    this.diffSetMap = setmap;
                }
            });
        });
        if (this.diffSet === undefined)
            throw new Error(`The difficulty ${input} does not exist in your Info.dat`);
        for (let i = 0; i < this.notes.length; i++)
            this.notes[i] = new note_1.Note().import(this.notes[i]);
        for (let i = 0; i < this.obstacles.length; i++)
            this.obstacles[i] = new wall_1.Wall().import(this.obstacles[i]);
        for (let i = 0; i < this.events.length; i++)
            this.events[i] = new event_1.Event().import(this.events[i]);
        if (this.customEvents !== undefined)
            for (let i = 0; i < this.customEvents.length; i++)
                this.customEvents[i] = new custom_event_1.CustomEvent().import(this.customEvents[i]);
        if (this.environment !== undefined)
            for (let i = 0; i < this.environment.length; i++)
                this.environment[i] = new environment_1.Environment().import(this.environment[i]);
        if (this.version === undefined)
            this.version = "2.2.0";
        exports.activeDiff = this;
    }
    optimize(optimize = new anim_optimizer_1.OptimizeSettings()) {
        const optimizeAnimation = (animation) => {
            animation.optimize(undefined, optimize);
        };
        this.notes.forEach(e => optimizeAnimation(e.animate)),
            this.obstacles.forEach(e => optimizeAnimation(e.animate)),
            this.customEvents.filter(e => e instanceof custom_event_1.CustomEventInternals.AnimateTrack).forEach(e => optimizeAnimation(e.animate));
        // TODO: Optimize point definitions
    }
    /**
     * Saves the difficulty.
     * @param {String} diffName Filename for the save. If left blank, the beatmap file name will be used for the save.
     */
    save(diffName) {
        diffName !== null && diffName !== void 0 ? diffName : (diffName = this.mapFile);
        if (!fs.existsSync(diffName))
            throw new Error(`The file ${diffName} does not exist and cannot be saved`);
        const outputJSON = (0, general_1.copy)(this.json);
        for (let i = 0; i < this.notes.length; i++) {
            const note = (0, general_1.copy)(this.notes[i]);
            if (exports.forceJumpsForNoodle && note.isModded) {
                note.NJS = note.NJS;
                note.offset = note.offset;
            }
            (0, general_1.jsonPrune)(note.json);
            outputJSON._notes[i] = note.json;
        }
        for (let i = 0; i < this.obstacles.length; i++) {
            const wall = (0, general_1.copy)(this.obstacles[i]);
            if (exports.forceJumpsForNoodle && wall.isModded) {
                wall.NJS = wall.NJS;
                wall.offset = wall.offset;
            }
            (0, general_1.jsonPrune)(wall.json);
            outputJSON._obstacles[i] = wall.json;
        }
        for (let i = 0; i < this.events.length; i++)
            outputJSON._events[i] = (0, general_1.copy)(this.events[i].json);
        (0, general_1.sortObjects)(outputJSON._events, "_time");
        (0, general_1.sortObjects)(outputJSON._notes, "_time");
        (0, general_1.sortObjects)(outputJSON._obstacles, "_time");
        if (this.customEvents !== undefined) {
            for (let i = 0; i < this.customEvents.length; i++)
                outputJSON._customData._customEvents[i] = (0, general_1.copy)(this.customEvents[i].json);
            (0, general_1.sortObjects)(outputJSON._customData._customEvents, "_time");
        }
        if (this.environment !== undefined) {
            for (let i = 0; i < this.environment.length; i++) {
                const json = (0, general_1.copy)(this.environment[i].json);
                (0, general_1.jsonRemove)(json, "_group");
                outputJSON._customData._environment[i] = json;
            }
        }
        fs.writeFileSync(diffName, JSON.stringify(outputJSON, null, 0));
    }
    /**
     * Add/remove a requirement from the difficulty.
     * @param {String} requirement
     * @param {Boolean} required True by default, set to false to remove the requirement.
     */
    require(requirement, required = true) {
        const requirements = {};
        let requirementsArr = this.requirements;
        if (requirementsArr === undefined)
            requirementsArr = [];
        requirementsArr.forEach(x => {
            requirements[x] = true;
        });
        requirements[requirement] = required;
        requirementsArr = [];
        for (const key in requirements) {
            if (requirements[key] === true)
                requirementsArr.push(key);
        }
        this.requirements = requirementsArr;
        exports.info.save();
    }
    /**
     * Add/remove a suggestion from the difficulty.
     * @param {String} suggestion
     * @param {Boolean} suggested True by default, set to false to remove the suggestion.
     */
    suggest(suggestion, suggested = true) {
        const suggestions = {};
        let suggestionsArr = this.suggestions;
        if (suggestionsArr === undefined)
            suggestionsArr = [];
        suggestionsArr.forEach(x => {
            suggestions[x] = true;
        });
        suggestions[suggestion] = suggested;
        suggestionsArr = [];
        for (const key in suggestions) {
            if (suggestions[key] === true)
                suggestionsArr.push(key);
        }
        this.suggestions = suggestionsArr;
        exports.info.save();
    }
    /**
     * Set a setting.
     * @param {String} setting The path of the setting.
     * @param {Any} value The value of the setting, leave blank to remove setting.
     */
    setSetting(setting, value = undefined) {
        this.updateSets(this.settings, setting, value);
    }
    updateSets(object, property, value) {
        (0, general_1.jsonSet)(object, property, value);
        if (!(0, general_1.isEmptyObject)(value))
            (0, general_1.jsonPrune)(this.diffSetMap);
        exports.info.save();
    }
    colorArrayToTuple(array) { return { r: array[0], g: array[1], b: array[2] }; }
    // Info.dat
    get NJS() { return (0, general_1.jsonGet)(this.diffSetMap, "_noteJumpMovementSpeed"); }
    get offset() { return (0, general_1.jsonGet)(this.diffSetMap, "_noteJumpStartBeatOffset"); }
    get fileName() { return (0, general_1.jsonGet)(this.diffSetMap, "_beatmapFilename"); }
    get diffSetName() { return (0, general_1.jsonGet)(this.diffSet, "_beatmapCharacteristicName"); }
    get name() { return (0, general_1.jsonGet)(this.diffSetMap, "_difficulty"); }
    get diffRank() { return (0, general_1.jsonGet)(this.diffSetMap, "_difficultyRank"); }
    get requirements() { return (0, general_1.jsonGet)(this.diffSetMap, "_customData._requirements", []); }
    get suggestions() { return (0, general_1.jsonGet)(this.diffSetMap, "_customData._suggestions", []); }
    get settings() { return (0, general_1.jsonGet)(this.diffSetMap, "_customData._settings", {}); }
    get warnings() { return (0, general_1.jsonGet)(this.diffSetMap, "_customData._warnings"); }
    get information() { return (0, general_1.jsonGet)(this.diffSetMap, "_customData._information"); }
    get label() { return (0, general_1.jsonGet)(this.diffSetMap, "_customData._difficultyLabel"); }
    get editorOffset() { return (0, general_1.jsonGet)(this.diffSetMap, "_customData._editorOffset"); }
    get editorOldOffset() { return (0, general_1.jsonGet)(this.diffSetMap, "_customData._editorOldOffset"); }
    get colorLeft() { return (0, general_1.jsonGet)(this.diffSetMap, "_customData._colorLeft"); }
    get colorRight() { return (0, general_1.jsonGet)(this.diffSetMap, "_customData._colorRight"); }
    get lightColorLeft() { return (0, general_1.jsonGet)(this.diffSetMap, "_customData._envColorLeft"); }
    get lightColorRight() { return (0, general_1.jsonGet)(this.diffSetMap, "_customData._envColorRight"); }
    get boostColorLeft() { return (0, general_1.jsonGet)(this.diffSetMap, "_customData._envColorLeftBoost"); }
    get boostColorRight() { return (0, general_1.jsonGet)(this.diffSetMap, "_customData._envColorRightBoost"); }
    get obstacleColor() { return (0, general_1.jsonGet)(this.diffSetMap, "_customData._obstacleColor"); }
    set NJS(value) { this.updateSets(this.diffSetMap, "_noteJumpMovementSpeed", value); }
    set offset(value) { this.updateSets(this.diffSetMap, "_noteJumpStartBeatOffset", value); }
    set fileName(value) { this.updateSets(this.diffSetMap, "_beatmapFilename", value); }
    set diffSetName(value) { this.updateSets(this.diffSet, "_beatmapCharacteristicName", value); }
    set name(value) { this.updateSets(this.diffSetMap, "_difficulty", value); }
    set diffRank(value) { this.updateSets(this.diffSetMap, "_difficultyRank", value); }
    set requirements(value) { this.updateSets(this.diffSetMap, "_customData._requirements", value); }
    set suggestions(value) { this.updateSets(this.diffSetMap, "_customData._suggestions", value); }
    set settings(value) { this.updateSets(this.diffSetMap, "_customData._settings", value); }
    set warnings(value) { this.updateSets(this.diffSetMap, "_customData._warnings", value); }
    set information(value) { this.updateSets(this.diffSetMap, "_customData._information", value); }
    set label(value) { this.updateSets(this.diffSetMap, "_customData._difficultyLabel", value); }
    set editorOffset(value) { this.updateSets(this.diffSetMap, "_customData._editorOffset", value); }
    set editorOldOffset(value) { this.updateSets(this.diffSetMap, "_customData._editorOldOffset", value); }
    set colorLeft(value) { this.updateSets(this.diffSetMap, "_customData._colorLeft", this.colorArrayToTuple(value)); }
    set colorRight(value) { this.updateSets(this.diffSetMap, "_customData._colorRight", this.colorArrayToTuple(value)); }
    set lightColorLeft(value) { this.updateSets(this.diffSetMap, "_customData._envColorLeft", this.colorArrayToTuple(value)); }
    set lightColorRight(value) { this.updateSets(this.diffSetMap, "_customData._envColorRight", this.colorArrayToTuple(value)); }
    set boostColorLeft(value) { this.updateSets(this.diffSetMap, "_customData._envColorLeftBoost", this.colorArrayToTuple(value)); }
    set boostColorRight(value) { this.updateSets(this.diffSetMap, "_customData._envColorRightBoost", this.colorArrayToTuple(value)); }
    set obstacleColor(value) { this.updateSets(this.diffSetMap, "_customData._obstacleColor", this.colorArrayToTuple(value)); }
    // Map
    get version() { return (0, general_1.jsonGet)(this.json, "_version"); }
    get notes() { return (0, general_1.jsonGet)(this.json, "_notes"); }
    get obstacles() { return (0, general_1.jsonGet)(this.json, "_obstacles"); }
    get events() { return (0, general_1.jsonGet)(this.json, "_events"); }
    get waypoints() { return (0, general_1.jsonGet)(this.json, "_waypoints"); }
    get customData() { return (0, general_1.jsonGet)(this.json, "_customData", {}); }
    get customEvents() { return (0, general_1.jsonGet)(this.json, "_customData._customEvents", []); }
    get pointDefinitions() { return (0, general_1.jsonGet)(this.json, "_customData._pointDefinitions", []); }
    get environment() { return (0, general_1.jsonGet)(this.json, "_customData._environment", []); }
    set version(value) { (0, general_1.jsonSet)(this.json, "_version", value); }
    set notes(value) { (0, general_1.jsonSet)(this.json, "_notes", value); }
    set obstacles(value) { (0, general_1.jsonSet)(this.json, "_obstacles", value); }
    set events(value) { (0, general_1.jsonSet)(this.json, "_events", value); }
    set waypoints(value) { (0, general_1.jsonSet)(this.json, "_waypoints", value); }
    set customData(value) { (0, general_1.jsonSet)(this.json, "_customData", value); }
    set customEvents(value) { (0, general_1.jsonSet)(this.json, "_customData._customEvents", value); }
    set pointDefinitions(value) { (0, general_1.jsonSet)(this.json, "_customData._pointDefinitions", value); }
    set environment(value) { (0, general_1.jsonSet)(this.json, "_customData._environment", value); }
}
exports.Difficulty = Difficulty;
class Info {
    constructor() {
        this.fileName = "Info.dat";
    }
    load(path) {
        const fileName = path !== null && path !== void 0 ? path : this.fileName;
        if (fs.existsSync(fileName)) {
            this.json = JSON.parse(fs.readFileSync(fileName, "utf-8"));
            this.fileName = fileName;
        }
        else {
            throw new Error(`The file "${fileName}" does not exist.`);
        }
    }
    /**
     * Saves the Info.dat
     */
    save() {
        if (!this.json)
            throw new Error("The Info object has not been loaded.");
        fs.writeFileSync(this.fileName, JSON.stringify(this.json, null, 2));
    }
    updateInfo(object, property, value) {
        (0, general_1.jsonSet)(object, property, value);
        exports.info.save();
    }
    get version() { return (0, general_1.jsonGet)(this.json, "_version"); }
    get name() { return (0, general_1.jsonGet)(this.json, "_songName"); }
    get subName() { return (0, general_1.jsonGet)(this.json, "_songSubName"); }
    get authorName() { return (0, general_1.jsonGet)(this.json, "_songAuthorName"); }
    get mapper() { return (0, general_1.jsonGet)(this.json, "_levelAuthorName"); }
    get BPM() { return (0, general_1.jsonGet)(this.json, "_beatsPerMinute"); }
    get previewStart() { return (0, general_1.jsonGet)(this.json, "_previewStartTime"); }
    get previewDuration() { return (0, general_1.jsonGet)(this.json, "_previewDuration"); }
    get songOffset() { return (0, general_1.jsonGet)(this.json, "_songTimeOffset"); }
    get shuffle() { return (0, general_1.jsonGet)(this.json, "_shuffle"); }
    get shufflePeriod() { return (0, general_1.jsonGet)(this.json, "_shufflePeriod"); }
    get coverFileName() { return (0, general_1.jsonGet)(this.json, "_coverImageFilename"); }
    get songFileName() { return (0, general_1.jsonGet)(this.json, "_songFilename"); }
    get environment() { return (0, general_1.jsonGet)(this.json, "_environmentName"); }
    get environment360() { return (0, general_1.jsonGet)(this.json, "_allDirectionsEnvironmentName"); }
    get customData() { return (0, general_1.jsonGet)(this.json, "_customData"); }
    get editors() { return (0, general_1.jsonGet)(this.json, "_customData._editors"); }
    get contributors() { return (0, general_1.jsonGet)(this.json, "_customData._contributors"); }
    get customEnvironment() { return (0, general_1.jsonGet)(this.json, "_customData._customEnvironment"); }
    get customEnvironmentHash() { return (0, general_1.jsonGet)(this.json, "_customData._customEnvironmentHash"); }
    set version(value) { this.updateInfo(this.json, "_version", value); }
    set name(value) { this.updateInfo(this.json, "_songName", value); }
    set subName(value) { this.updateInfo(this.json, "_songSubName", value); }
    set authorName(value) { this.updateInfo(this.json, "_songAuthorName", value); }
    set mapper(value) { this.updateInfo(this.json, "_levelAuthorName", value); }
    set BPM(value) { this.updateInfo(this.json, "_beatsPerMinute", value); }
    set previewStart(value) { this.updateInfo(this.json, "_previewStartTime", value); }
    set previewDuration(value) { this.updateInfo(this.json, "_previewDuration", value); }
    set songOffset(value) { this.updateInfo(this.json, "_songTimeOffset", value); }
    set shuffle(value) { this.updateInfo(this.json, "_shuffle", value); }
    set shufflePeriod(value) { this.updateInfo(this.json, "_shufflePeriod", value); }
    set coverFileName(value) { this.updateInfo(this.json, "_coverImageFilename", value); }
    set songFileName(value) { this.updateInfo(this.json, "_songFilename", value); }
    set environment(value) { this.updateInfo(this.json, "_environmentName", value); }
    set environment360(value) { this.updateInfo(this.json, "_allDirectionsEnvironmentName", value); }
    set customData(value) { this.updateInfo(this.json, "_customData", value); }
    set editors(value) { this.updateInfo(this.json, "_customData._editors", value); }
    set contributors(value) { this.updateInfo(this.json, "_customData._contributors", value); }
    set customEnvironment(value) { this.updateInfo(this.json, "_customData._customEnvironment", value); }
    set customEnvironmentHash(value) { this.updateInfo(this.json, "_customData._customEnvironmentHash", value); }
}
exports.Info = Info;
exports.info = new Info();
exports.forceJumpsForNoodle = true;
/**
 * Set the difficulty that objects are being created for.
 * @param {Object} diff
 */
function activeDiffSet(diff) { exports.activeDiff = diff; }
exports.activeDiffSet = activeDiffSet;
/**
 * Set whether exported walls and notes with custom data will have their NJS / Offset forced.
 * This helps avoid things like JDFixer breaking things. Should be set before your scripting.
 * @param {Boolean} value
 */
function forceJumpsForNoodleSet(value) { exports.forceJumpsForNoodle = value; }
exports.forceJumpsForNoodleSet = forceJumpsForNoodleSet;
/**
 * Automatically zip the map, including only necessary files.
 * @param {String[]} excludeDiffs Difficulties to exclude.
 * @param {String} zipName Name of the zip (don't include ".zip"). Uses folder name if undefined.
 */
function exportZip(excludeDiffs = [], zipName) {
    if (!exports.info.json)
        throw new Error("The Info object has not been loaded.");
    const absoluteInfoFileName = exports.info.fileName === "Info.dat" ? process.cwd() + `\\${exports.info.fileName}` : exports.info.fileName;
    const workingDir = path_1.default.parse(absoluteInfoFileName).dir;
    const exportInfo = (0, general_1.copy)(exports.info.json);
    const files = [];
    function pushFile(file) {
        const dir = workingDir + `\\${file}`;
        if (fs.existsSync(dir))
            files.push(dir);
    }
    pushFile(exportInfo._songFilename);
    if (exportInfo._coverImageFilename !== undefined)
        pushFile(exportInfo._coverImageFilename);
    for (let s = 0; s < exportInfo._difficultyBeatmapSets.length; s++) {
        const set = exportInfo._difficultyBeatmapSets[s];
        for (let m = 0; m < set._difficultyBeatmaps.length; m++) {
            const map = set._difficultyBeatmaps[m];
            let passed = true;
            excludeDiffs.forEach(d => {
                if (map._beatmapFilename === d) {
                    set._difficultyBeatmaps.splice(m, 1);
                    m--;
                    passed = false;
                }
            });
            if (passed)
                pushFile(map._beatmapFilename);
        }
        if (set._difficultyBeatmaps.length === 0) {
            exportInfo._difficultyBeatmapSets.splice(s, 1);
            s--;
        }
    }
    zipName !== null && zipName !== void 0 ? zipName : (zipName = `${path_1.default.parse(workingDir).name}`);
    zipName = workingDir + `\\${zipName}.zip`;
    if (!fs.existsSync(zipName))
        fs.writeFileSync(zipName, "");
    const tempInfo = workingDir + `\\TEMPINFO.dat`;
    files.push(tempInfo);
    fs.writeFileSync(tempInfo, JSON.stringify(exportInfo, null, 0));
    fs.unlinkSync(zipName);
    const zip = node_7z_1.default.add(zipName, files, { $bin: _7zip_bin_1.default.path7za });
    zip.on('end', function () {
        const zip2 = node_7z_1.default.rename(zipName, [
            ["TEMPINFO.dat", path_1.default.parse(exports.info.fileName).base]
        ], { $bin: _7zip_bin_1.default.path7za });
        zip2.on('end', function () {
            fs.unlinkSync(tempInfo);
        });
    });
}
exports.exportZip = exportZip;
/**
 * Transfer the visual aspect of maps to other difficulties.
 * More specifically modded walls, custom events, point definitions, environment enhancements, and lighting events.
 * @param {Array} diffs The difficulties being effected.
 * @param {Function} forDiff A function to run over each difficulty.
 * The activeDiff keyword will change to be each difficulty running during this function.
 * Be mindful that the external difficulties don't have an input/output structure,
 * so new pushed notes for example may not be cleared on the next run and would build up.
 */
function transferVisuals(diffs, forDiff) {
    const startActive = exports.activeDiff;
    diffs.forEach(x => {
        const workingDiff = new Difficulty(x);
        workingDiff.environment = startActive.environment;
        workingDiff.pointDefinitions = startActive.pointDefinitions;
        workingDiff.customEvents = startActive.customEvents;
        workingDiff.events = startActive.events;
        for (let y = 0; y < workingDiff.obstacles.length; y++) {
            const obstacle = workingDiff.obstacles[y];
            if (obstacle.isModded) {
                workingDiff.obstacles.splice(y, 1);
                y--;
            }
        }
        startActive.obstacles.forEach(y => { if (y.isModded)
            workingDiff.obstacles.push(y); });
        if (forDiff !== undefined)
            forDiff(workingDiff);
        workingDiff.save();
    });
    activeDiffSet(startActive);
}
exports.transferVisuals = transferVisuals;
