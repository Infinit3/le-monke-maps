"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toPointDef = exports.combineAnimations = exports.getValuesAtTime = exports.isSimple = exports.optimizeArray = exports.simplifyArray = exports.complexifyArray = exports.Track = exports.Keyframe = exports.Animation = exports.AnimationInternals = void 0;
const beatmap_1 = require("./beatmap");
const constants_1 = require("./constants");
const general_1 = require("./general");
var AnimationInternals;
(function (AnimationInternals) {
    class BaseAnimation {
        constructor(length = undefined, data = undefined) {
            this.json = {};
            length !== null && length !== void 0 ? length : (length = 1);
            this.length = length;
            if (data !== undefined)
                this.json = data;
        }
        /**
         * Clear animation data. Leave blank to completely clear animation.
         */
        clear(property = undefined) {
            if (property !== undefined)
                delete this.json[property];
            else
                Object.keys(this.json).forEach(x => { delete this.json[x]; });
        }
        /**
         * Set a property's animations. Does not edit the value.
         * @param {String} property
         * @param {*} value
         */
        set(property, value) { this.json[property] = value; }
        /**
         * Get a property's animations.
         * @param {String} property
         * @param {Number} time Option to get the values of a property at a certain time. Does not account for splines.
         * Time can be in length of animation or between 0 and 1 if negative.
         * @returns {*}
         */
        get(property, time = undefined) {
            if (time === undefined)
                return this.json[property];
            else {
                time = this.convertTime(time);
                return getValuesAtTime(property, this.json[property], time);
            }
        }
        /**
         * Add animations to a property, also sorts by time and makes optimizations if possible.
         * @param {String} property
         * @param {*} value
         */
        add(property, value) {
            value = this.convert(complexifyArray(value));
            let concatArray = value.concat(complexifyArray(this.json[property]));
            let newValue = simplifyArray(concatArray.sort((a, b) => new Keyframe(a).time - new Keyframe(b).time));
            this.json[property] = newValue;
        }
        /**
         * Remove similar values to cut down on keyframe count.
         * @param {Number} accuracy Multiplier for the max difference that values are considered "similar".
         * @param {String} property Optimize only a single property, or set to undefined to optimize all.
         */
        optimize(accuracy = undefined, property = undefined) {
            accuracy !== null && accuracy !== void 0 ? accuracy : (accuracy = 1);
            if (property === undefined) {
                Object.keys(this.json).forEach(key => {
                    if (Array.isArray(this.json[key])) {
                        this.set(key, optimizeArray(this.get(key), lookupLenience(key)));
                    }
                });
            }
            else
                this.set(property, optimizeArray(this.get(property), lookupLenience(property)));
            function lookupLenience(prop) {
                if (prop === constants_1.ANIM.POSITION || prop === constants_1.ANIM.LOCAL_POSITION || prop === constants_1.ANIM.DEFINITE_POSITION)
                    return 0.1 * accuracy;
                if (prop === constants_1.ANIM.SCALE)
                    return 0.05 * accuracy;
                if (prop === constants_1.ANIM.ROTATION || prop === constants_1.ANIM.LOCAL_ROTATION)
                    return 4 * accuracy;
                return 0;
            }
        }
        convert(value) {
            return value.map(x => {
                let time = new Keyframe(x).timeIndex;
                x[time] = this.convertTime(x[time]);
                return x;
            });
        }
        convertTime(time) {
            if (time >= 0)
                return time / this.length;
            else
                return time * -1;
        }
    }
    AnimationInternals.BaseAnimation = BaseAnimation;
    class ObjectAnimation extends BaseAnimation {
        get position() { return this.get(constants_1.ANIM.POSITION); }
        get definitePosition() { return this.get(constants_1.ANIM.DEFINITE_POSITION); }
        get rotation() { return this.get(constants_1.ANIM.ROTATION); }
        get localRotation() { return this.get(constants_1.ANIM.LOCAL_ROTATION); }
        get scale() { return this.get(constants_1.ANIM.SCALE); }
        get dissolve() { return this.get(constants_1.ANIM.DISSOLVE); }
        get color() { return this.get(constants_1.ANIM.COLOR); }
        get interactable() { return this.get(constants_1.ANIM.INTERACTABLE); }
        get time() { return this.get(constants_1.ANIM.TIME); }
        set position(value) { this.add(constants_1.ANIM.POSITION, value); }
        set definitePosition(value) { this.add(constants_1.ANIM.DEFINITE_POSITION, value); }
        set rotation(value) { this.add(constants_1.ANIM.ROTATION, value); }
        set localRotation(value) { this.add(constants_1.ANIM.LOCAL_ROTATION, value); }
        set scale(value) { this.add(constants_1.ANIM.SCALE, value); }
        set dissolve(value) { this.add(constants_1.ANIM.DISSOLVE, value); }
        set color(value) { this.add(constants_1.ANIM.COLOR, value); }
        set interactable(value) { this.add(constants_1.ANIM.INTERACTABLE, value); }
        set time(value) { this.add(constants_1.ANIM.TIME, value); }
    }
    class NoteAnimation extends ObjectAnimation {
        get dissolveArrow() { return this.get(constants_1.ANIM.DISSOLVE_ARROW); }
        set dissolveArrow(value) { this.add(constants_1.ANIM.DISSOLVE_ARROW, value); }
    }
    AnimationInternals.NoteAnimation = NoteAnimation;
    class WallAnimation extends ObjectAnimation {
    }
    AnimationInternals.WallAnimation = WallAnimation;
    class EnvironmentAnimation extends BaseAnimation {
        get position() { return this.get(constants_1.ANIM.POSITION); }
        get rotation() { return this.get(constants_1.ANIM.ROTATION); }
        get localPosition() { return this.get(constants_1.ANIM.LOCAL_POSITION); }
        get localRotation() { return this.get(constants_1.ANIM.LOCAL_ROTATION); }
        get scale() { return this.get(constants_1.ANIM.SCALE); }
        set position(value) { this.add(constants_1.ANIM.POSITION, value); }
        set rotation(value) { this.add(constants_1.ANIM.ROTATION, value); }
        set localPosition(value) { this.add(constants_1.ANIM.LOCAL_POSITION, value); }
        set localRotation(value) { this.add(constants_1.ANIM.LOCAL_ROTATION, value); }
        set scale(value) { this.add(constants_1.ANIM.SCALE, value); }
    }
    AnimationInternals.EnvironmentAnimation = EnvironmentAnimation;
    class FogAnimation extends BaseAnimation {
        get attenuation() { return this.get(constants_1.ANIM.ATTENUATION); }
        get offset() { return this.get(constants_1.ANIM.OFFSET); }
        get startY() { return this.get(constants_1.ANIM.STARTY); }
        get height() { return this.get(constants_1.ANIM.HEIGHT); }
        set attenuation(value) { this.add(constants_1.ANIM.ATTENUATION, value); }
        set offset(value) { this.add(constants_1.ANIM.OFFSET, value); }
        set startY(value) { this.add(constants_1.ANIM.STARTY, value); }
        set height(value) { this.add(constants_1.ANIM.HEIGHT, value); }
    }
    AnimationInternals.FogAnimation = FogAnimation;
    class AbstractAnimation extends ObjectAnimation {
        get position() { return this.get(constants_1.ANIM.POSITION); }
        get localPosition() { return this.get(constants_1.ANIM.LOCAL_POSITION); }
        get definitePosition() { return this.get(constants_1.ANIM.DEFINITE_POSITION); }
        get rotation() { return this.get(constants_1.ANIM.ROTATION); }
        get localRotation() { return this.get(constants_1.ANIM.LOCAL_ROTATION); }
        get scale() { return this.get(constants_1.ANIM.SCALE); }
        get dissolve() { return this.get(constants_1.ANIM.DISSOLVE); }
        get dissolveArrow() { return this.get(constants_1.ANIM.DISSOLVE_ARROW); }
        get color() { return this.get(constants_1.ANIM.COLOR); }
        get interactable() { return this.get(constants_1.ANIM.INTERACTABLE); }
        get time() { return this.get(constants_1.ANIM.TIME); }
        get attenuation() { return this.get(constants_1.ANIM.ATTENUATION); }
        get offset() { return this.get(constants_1.ANIM.OFFSET); }
        get startY() { return this.get(constants_1.ANIM.STARTY); }
        get height() { return this.get(constants_1.ANIM.HEIGHT); }
        set position(value) { this.add(constants_1.ANIM.POSITION, value); }
        set localPosition(value) { this.add(constants_1.ANIM.LOCAL_POSITION, value); }
        set definitePosition(value) { this.add(constants_1.ANIM.DEFINITE_POSITION, value); }
        set rotation(value) { this.add(constants_1.ANIM.ROTATION, value); }
        set localRotation(value) { this.add(constants_1.ANIM.LOCAL_ROTATION, value); }
        set scale(value) { this.add(constants_1.ANIM.SCALE, value); }
        set dissolve(value) { this.add(constants_1.ANIM.DISSOLVE, value); }
        set dissolveArrow(value) { this.add(constants_1.ANIM.DISSOLVE_ARROW, value); }
        set color(value) { this.add(constants_1.ANIM.COLOR, value); }
        set interactable(value) { this.add(constants_1.ANIM.INTERACTABLE, value); }
        set time(value) { this.add(constants_1.ANIM.TIME, value); }
        set attenuation(value) { this.add(constants_1.ANIM.ATTENUATION, value); }
        set offset(value) { this.add(constants_1.ANIM.OFFSET, value); }
        set startY(value) { this.add(constants_1.ANIM.STARTY, value); }
        set height(value) { this.add(constants_1.ANIM.HEIGHT, value); }
    }
    AnimationInternals.AbstractAnimation = AbstractAnimation;
})(AnimationInternals = exports.AnimationInternals || (exports.AnimationInternals = {}));
class Animation extends AnimationInternals.BaseAnimation {
    /**
    * Noodle animation manager.
    * The time in each keyframe is divided by the length.
    * Use a negative number or don't specify a length to use a range between 0 and 1.
    * Setting a property will add any existing keyframes and sort by time.
    * @param {Number} length
    */
    constructor(length = 1) { super(length); }
    /**
    * Create an animation using JSON.
    * @param {Object} json
    * @returns {AbstractAnimation}
    */
    import(json) { return new AnimationInternals.AbstractAnimation(this.length, json); }
    /**
     * Create an event with no particular identity.
     * @returns {AbstractAnimation};
     */
    abstract(json = {}) { return this.import(json); }
    /**
     * State that this animation is for a note.
     * @param {Object} json
     * @returns
     */
    noteAnimation(json = undefined) { return new AnimationInternals.NoteAnimation(this.length, json); }
    /**
     * State that this animation is for a wall.
     * @param {Object} json
     * @returns
     */
    wallAnimation(json = undefined) { return new AnimationInternals.WallAnimation(this.length, json); }
    /**
     * State that this animation is for an environment object.
     * @param {Object} json
     * @returns
     */
    environmentAnimation(json = undefined) { return new AnimationInternals.EnvironmentAnimation(this.length, json); }
    /**
     * State that this animation is for fog.
     * @param {Object} json
     * @returns
     */
    fogAnimation(json = undefined) { return new AnimationInternals.FogAnimation(this.length, json); }
}
exports.Animation = Animation;
class Keyframe {
    constructor(data) {
        this.values = [];
        this.timeIndex = 0;
        this.time = 0;
        this.easing = undefined;
        this.spline = undefined;
        this.timeIndex = this.getTimeIndex(data);
        this.time = data[this.timeIndex];
        this.values = this.getValues(data);
        this.easing = this.getEasing(data);
        this.spline = this.getSpline(data);
    }
    getValues(arr) {
        let time = this.getTimeIndex(arr);
        return arr.slice(0, time);
    }
    getTimeIndex(arr) {
        for (let i = arr.length - 1; i >= 0; i--) {
            if (typeof arr[i] !== "string")
                return i;
        }
    }
    getEasing(arr) {
        return arr.filter(x => typeof x === "string" && x.includes("ease"))[0];
    }
    getSpline(arr) {
        return arr.filter(x => typeof x === "string" && x.includes("spline"))[0];
    }
    get data() {
        let output = [...this.values, this.time];
        if (this.easing !== undefined)
            output.push(this.easing);
        if (this.spline !== undefined)
            output.push(this.spline);
        return output;
    }
}
exports.Keyframe = Keyframe;
class Track {
    /**
     * Handler for the track property.
     * @param {TrackValue} value
     */
    constructor(value) { this.value = value; }
    /**
     * Safely check if either the array contains this value or the track is equal to this value.
     * @param {String} value
     * @returns
     */
    has(value) {
        if (this.value === undefined)
            return false;
        if (typeof this.value === "string")
            return this.value === value;
        else
            return this.value.some(x => x === value);
    }
}
exports.Track = Track;
/**
 * Specific function for animations, converts an array with a single element to be double nested.
 * @param {Array} array
 * @returns {Array}
 */
function complexifyArray(array) {
    if (array === undefined)
        return [];
    if (!isSimple(array))
        return array;
    return [[...array, 0]];
}
exports.complexifyArray = complexifyArray;
/**
 * Specific function for animations, converts a double nested array with a single element to an array with a single element.
 * @param {Array} array
 * @returns {Array}
 */
function simplifyArray(array) {
    if (array === undefined)
        return [];
    if (array.length <= 1 && !isSimple(array) && new Keyframe(array[0]).time === 0) {
        let newArr = array[0];
        newArr.pop();
        return newArr;
    }
    return array;
}
exports.simplifyArray = simplifyArray;
/**
 * Specific function for animations, removes similar keyframes from an animation.
 * @param {Array} animation
 * @param {Number} lenience The maximum distance values can be considered similar.
 * @returns {Array}
 */
function optimizeArray(animation, lenience = 0.1) {
    let keyframes = (0, general_1.copy)(complexifyArray(animation)).map(x => new Keyframe(x));
    // not enough points to optimize
    if (keyframes.length <= 2)
        return simplifyArray(keyframes.map(x => x.data));
    // Initialize an array with values of 0
    // TODO: Why keep an array of differences when we don't need it?
    let differences = [];
    for (let i = 0; i < keyframes[0].values.length; i++)
        differences[i] = 0;
    // Checks if point a-b have similar keyframe data including time
    for (let i = 1; i < keyframes.length; i++) {
        let left = keyframes[i - 1];
        let point = keyframes[i];
        // While the keyframes may be similar, their easing/spline difference is
        // non-negligible to the animation path and therefore should not be considered for removal
        if ((left === null || left === void 0 ? void 0 : left.easing) !== point.easing)
            continue;
        if ((left === null || left === void 0 ? void 0 : left.spline) !== point.spline)
            continue;
        // TODO: instead of comparing left-middle value similarity and middle-right value similarity,
        // compare if middle - left / right is similar to left - right
        // or just compare left-middle instead
        // - Fern
        if ((0, general_1.arrEqual)(left.values, point.values, lenience)) {
            checkSplice();
        }
        // TODO: Make this less complicated
        // If you're already checking if the arrays are similar, 
        // why bother check again ?
        function checkSplice() {
            if (left !== undefined) {
                for (let j = 0; j < differences.length; j++) {
                    differences[j] += point[j] - left[j];
                    if (Math.abs(differences[j]) > lenience) {
                        for (let k = 0; k < differences.length; k++)
                            differences[k] = 0;
                        return;
                    }
                }
                deleteElem();
            }
            function deleteElem() { keyframes.splice(i, 1); i--; }
        }
    }
    return simplifyArray(keyframes.map(x => x.data));
}
exports.optimizeArray = optimizeArray;
/**
 * Specific function for animations, checks if an animation isn't double nested.
 * @param {Object} array
 * @returns {Boolean}
 */
function isSimple(array) {
    return typeof array[0] !== "object";
}
exports.isSimple = isSimple;
/**
 * Get the values of an animation at a given time. Accounts for easings and splines!
 * @param {String} property
 * @param {Array} animation
 * @param {Time} time
 * @returns {Array}
 */
function getValuesAtTime(property, animation, time) {
    animation = complexifyArray(animation);
    let timeInfo = timeInKeyframes(time, animation);
    if (timeInfo.interpolate) {
        if (property === constants_1.ANIM.ROTATION || property === constants_1.ANIM.LOCAL_ROTATION) {
            return (0, general_1.lerpRotation)(timeInfo.l.values, timeInfo.r.values, timeInfo.normalTime);
        }
        else {
            // TODO: Move this into its own function, this is bad
            if (timeInfo.r.spline === "splineCatmullRom") {
                let p0 = timeInfo.leftIndex - 1 < 0 ? timeInfo.l.values : new Keyframe(animation[timeInfo.leftIndex - 1]).values;
                let p1 = timeInfo.l.values;
                let p2 = timeInfo.r.values;
                let p3 = timeInfo.rightIndex + 1 > animation.length - 1 ? timeInfo.r.values : new Keyframe(animation[timeInfo.rightIndex + 1]).values;
                let t = timeInfo.normalTime;
                let tt = t * t;
                let ttt = tt * t;
                let q0 = -ttt + (2 * tt) - t;
                let q1 = (3 * ttt) - (5 * tt) + 2;
                let q2 = (-3 * ttt) + (4 * tt) + t;
                let q3 = ttt - tt;
                let o0 = (0, general_1.arrMul)(p0, q0);
                let o1 = (0, general_1.arrMul)(p1, q1);
                let o2 = (0, general_1.arrMul)(p2, q2);
                let o3 = (0, general_1.arrMul)(p3, q3);
                return (0, general_1.arrMul)((0, general_1.arrAdd)((0, general_1.arrAdd)(o0, o1), (0, general_1.arrAdd)(o2, o3)), 0.5);
            }
            else {
                // TODO: Move this into a lerpArray function?
                return timeInfo.l.values.map((x, i) => {
                    return (0, general_1.lerp)(x, timeInfo.r.values[i], timeInfo.normalTime);
                });
            }
        }
    }
    else
        return timeInfo.l.values;
}
exports.getValuesAtTime = getValuesAtTime;
function timeInKeyframes(time, animation) {
    let l;
    let r;
    let normalTime = 0;
    if (animation.length === 0)
        return { interpolate: false };
    let first = new Keyframe(animation[0]);
    if (first.time >= time) {
        l = first;
        return { interpolate: false, l: l };
    }
    let last = new Keyframe((0, general_1.arrLast)(animation));
    if (last.time <= time) {
        l = last;
        return { interpolate: false, l: l };
    }
    let leftIndex = 0;
    let rightIndex = animation.length;
    while (leftIndex < rightIndex - 1) {
        let m = Math.floor((leftIndex + rightIndex) / 2);
        let pointTime = new Keyframe(animation[m]).time;
        if (pointTime < time)
            leftIndex = m;
        else
            rightIndex = m;
    }
    l = new Keyframe(animation[leftIndex]);
    r = new Keyframe(animation[rightIndex]);
    normalTime = (0, general_1.findFraction)(l.time, r.time - l.time, time);
    normalTime = (0, general_1.lerpEasing)(r.easing, normalTime);
    return {
        interpolate: true,
        l: l,
        r: r,
        normalTime: normalTime,
        leftIndex: leftIndex,
        rightIndex: rightIndex
    };
}
/**
 * Allows you to combine two animations together as long as atleast one of them has only a single keyframe.
 * @param {Array} anim1
 * @param {Array} anim2
 * @param {String} property Property that the animation originated from, important to determine how to combine.
 * @returns {Array}
 */
function combineAnimations(anim1, anim2, property) {
    let simpleArr = (0, general_1.copy)(anim1);
    let complexArr = (0, general_1.copy)(anim2);
    if (isSimple(anim1) && isSimple(anim2)) {
        complexArr = complexifyArray(anim2);
    }
    if (!isSimple(anim1) && isSimple(anim2)) {
        simpleArr = anim2;
        complexArr = anim1;
    }
    if (!isSimple(anim1) && !isSimple(anim2)) {
        console.warn(`[${anim1}] and [${anim2}] are unable to combine!`);
    }
    let editElem = function (e, e2) {
        if (property === (constants_1.ANIM.POSITION || constants_1.ANIM.LOCAL_POSITION))
            e += e2;
        if (property === (constants_1.ANIM.ROTATION || constants_1.ANIM.LOCAL_ROTATION))
            e = (e + e2) % 360;
        if (property === (constants_1.ANIM.SCALE))
            e *= e2;
        return e;
    };
    for (let j = 0; j < complexArr.length; j++)
        for (let i = 0; i < simpleArr.length; i++) {
            complexArr[j][i] = editElem(complexArr[j][i], simpleArr[i]);
        }
    return complexArr;
}
exports.combineAnimations = combineAnimations;
/**
 * Export keyframes to a point definition.
 * @param {Array} animation
 * @param {String} name
 */
function toPointDef(animation, name) {
    if (beatmap_1.activeDiff.pointDefinitions === undefined)
        beatmap_1.activeDiff.pointDefinitions = [];
    beatmap_1.activeDiff.pointDefinitions.push({
        "_name": name,
        "_points": animation
    });
}
exports.toPointDef = toPointDef;
