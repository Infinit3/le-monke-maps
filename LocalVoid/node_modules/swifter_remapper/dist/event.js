"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Event = exports.EventInternals = void 0;
const constants_1 = require("./constants");
const beatmap_1 = require("./beatmap");
const general_1 = require("./general");
var EventInternals;
(function (EventInternals) {
    class BaseEvent {
        constructor(time) {
            this.json = {
                _time: 0,
                _type: 0,
                _value: 0
            };
            if (time instanceof Object) {
                this.json = time;
                return;
            }
            this.time = time;
        }
        /**
        * Push this event to the difficulty
        */
        push() {
            beatmap_1.activeDiff.events.push((0, general_1.copy)(this));
            return this;
        }
        get time() { return this.json._time; }
        get type() { return this.json._type; }
        get value() { return this.json._value; }
        get floatValue() { return this.json._floatValue; }
        get customData() { return (0, general_1.jsonGet)(this.json, "_customData"); }
        set time(value) { this.json._time = value; }
        set type(value) { this.json._type = value; }
        set value(value) { this.json._value = value; }
        set floatValue(value) { this.json._floatValue = value; }
        set customData(value) { (0, general_1.jsonSet)(this.json, "_customData", value); }
        get isModded() {
            if (this.customData === undefined)
                return false;
            let customData = (0, general_1.copy)(this.customData);
            (0, general_1.jsonPrune)(customData);
            return !(0, general_1.isEmptyObject)(customData);
        }
    }
    EventInternals.BaseEvent = BaseEvent;
    class LightEvent extends EventInternals.BaseEvent {
        constructor(json, type) {
            super(json);
            this.type = type;
        }
        /**
         * Create an event that turns lights off.
         * @returns
         */
        off() {
            this.value = constants_1.EVENT.OFF;
            return this;
        }
        /**
         * Create an event that turns lights on.
         * @param {Array} color Can be boolean to determine if the light is blue (true), or a color.
         * @param {Number | Array} lightID
         * @returns
         */
        on(color, lightID = undefined) {
            this.value = (typeof color === "boolean" && color) ? constants_1.EVENT.BLUE_ON : constants_1.EVENT.RED_ON;
            if (typeof color !== "boolean")
                this.color = color;
            if (lightID !== undefined)
                this.lightID = lightID;
            return this;
        }
        /**
         * Create an event that flashes the lights.
         * @param {Array} color Can be boolean to determine if the light is blue (true), or a color.
         * @param {Number | Array} lightID
         * @returns
         */
        flash(color, lightID = undefined) {
            this.value = (typeof color === "boolean" && color) ? constants_1.EVENT.BLUE_FLASH : constants_1.EVENT.RED_FLASH;
            if (typeof color !== "boolean")
                this.color = color;
            if (lightID !== undefined)
                this.lightID = lightID;
            return this;
        }
        /**
         * Create an event that fades the lights out.
         * @param {Array} color Can be boolean to determine if the light is blue (true), or a color.
         * @param {Number | Array} lightID
         * @returns
         */
        fade(color, lightID = undefined) {
            this.value = (typeof color === "boolean" && color) ? constants_1.EVENT.BLUE_FADE : constants_1.EVENT.RED_FADE;
            if (typeof color !== "boolean")
                this.color = color;
            if (lightID !== undefined)
                this.lightID = lightID;
            return this;
        }
        /**
         * Create an event that makes the lights fade in to this color from the previous.
         * @param {Array} color Can be boolean to determine if the light is blue (true), or a color.
         * @param {Number | Array} lightID
         * @returns
         */
        in(color, lightID = undefined) {
            this.value = (typeof color === "boolean" && color) ? constants_1.EVENT.BLUE_IN : constants_1.EVENT.RED_IN;
            if (typeof color !== "boolean")
                this.color = color;
            if (lightID !== undefined)
                this.lightID = lightID;
            return this;
        }
        /**
         * Create a light gradient between 2 colors. This feature is deprecated in Chroma.
         * @param {Array} startColor
         * @param {Array} endColor
         * @param {Number} duration
         * @param {String} easing
         * @returns
         */
        gradient(startColor, endColor, duration, easing = undefined) {
            this.startColor = startColor;
            this.endColor = endColor;
            this.duration = duration;
            this.value = 1;
            if (easing !== undefined)
                this.gradientEasing = easing;
            return this;
        }
        /**
        * Remove the subclass of the event, giving access to all properties, but can allow for invalid data.
        * @returns {AbstractEvent}
        */
        abstract() { return new Event().import(this.json); }
        get lightID() { return (0, general_1.jsonGet)(this.json, "_customData._lightID"); }
        get color() { return (0, general_1.jsonGet)(this.json, "_customData._color"); }
        get easing() { return (0, general_1.jsonGet)(this.json, "_customData._easing"); }
        get lerpType() { return (0, general_1.jsonGet)(this.json, "_customData._lerpType"); }
        get lightGradient() { return (0, general_1.jsonGet)(this.json, "_customData._lightGradient"); }
        get startColor() { return (0, general_1.jsonGet)(this.json, "_customData._lightGradient._startColor"); }
        get endColor() { return (0, general_1.jsonGet)(this.json, "_customData._lightGradient._endColor"); }
        get duration() { return (0, general_1.jsonGet)(this.json, "_customData._lightGradient._duration"); }
        get gradientEasing() { return (0, general_1.jsonGet)(this.json, "_customData._lightGradient._easing"); }
        set lightID(value) { (0, general_1.jsonSet)(this.json, "_customData._lightID", value); }
        set color(value) { (0, general_1.jsonSet)(this.json, "_customData._color", value); }
        set easing(value) { (0, general_1.jsonSet)(this.json, "_customData._easing", value); }
        set lerpType(value) { (0, general_1.jsonSet)(this.json, "_customData._lerpType", value); }
        set lightGradient(value) { (0, general_1.jsonSet)(this.json, "_customData._lightGradient", value); }
        set startColor(value) { (0, general_1.jsonSet)(this.json, "_customData._lightGradient._startColor", value); }
        set endColor(value) { (0, general_1.jsonSet)(this.json, "_customData._lightGradient._endColor", value); }
        set duration(value) { (0, general_1.jsonSet)(this.json, "_customData._lightGradient._duration", value); }
        set gradientEasing(value) { (0, general_1.jsonSet)(this.json, "_customData._lightGradient._easing", value); }
    }
    EventInternals.LightEvent = LightEvent;
    class LaserSpeedEvent extends EventInternals.BaseEvent {
        constructor(json, type, speed, direction = undefined, lockPosition = undefined) {
            super(json);
            this.type = type;
            if (speed % 1 === 0)
                this.value = speed;
            else
                this.speed = speed;
            if (direction !== undefined)
                this.direction = direction;
            if (lockPosition !== undefined)
                this.lockPosition = lockPosition;
        }
        /**
        * Remove the subclass of the event, giving access to all properties, but can allow for invalid data.
        * @returns {AbstractEvent}
        */
        abstract() { return new Event().import(this.json); }
        get lockPosition() { return (0, general_1.jsonGet)(this.json, "_customData._lockPosition"); }
        get speed() { return (0, general_1.jsonGet)(this.json, "_customData._speed"); }
        get direction() { return (0, general_1.jsonGet)(this.json, "_customData._direction"); }
        set lockPosition(value) { (0, general_1.jsonSet)(this.json, "_customData._lockPosition", value); }
        set speed(value) { (0, general_1.jsonSet)(this.json, "_customData._speed", value); }
        set direction(value) { (0, general_1.jsonSet)(this.json, "_customData._direction", value); }
    }
    EventInternals.LaserSpeedEvent = LaserSpeedEvent;
    class RingZoomEvent extends EventInternals.BaseEvent {
        constructor(json, step = undefined, speed = undefined) {
            super(json);
            this.type = constants_1.EVENT.RING_ZOOM;
            if (step !== undefined)
                this.step = step;
            if (speed !== undefined)
                this.speed = speed;
        }
        /**
        * Remove the subclass of the event, giving access to all properties, but can allow for invalid data.
        * @returns {AbstractEvent}
        */
        abstract() { return new Event().import(this.json); }
        get step() { return (0, general_1.jsonGet)(this.json, "_customData._step"); }
        get speed() { return (0, general_1.jsonGet)(this.json, "_customData._speed"); }
        set step(value) { (0, general_1.jsonSet)(this.json, "_customData._step", value); }
        set speed(value) { (0, general_1.jsonSet)(this.json, "_customData._speed", value); }
    }
    EventInternals.RingZoomEvent = RingZoomEvent;
    class RingSpinEvent extends EventInternals.BaseEvent {
        constructor(json, rotation = undefined, direction = undefined, step = undefined, speed = undefined, prop = undefined, reset = undefined, nameFilter = undefined, counterSpin = undefined) {
            super(json);
            this.type = constants_1.EVENT.RING_SPIN;
            if (rotation !== undefined)
                this.rotation = rotation;
            if (direction !== undefined)
                this.direction = direction;
            if (step !== undefined)
                this.step = step;
            if (speed !== undefined)
                this.speed = speed;
            if (prop !== undefined)
                this.prop = prop;
            if (reset !== undefined)
                this.reset = reset;
            if (nameFilter !== undefined)
                this.nameFilter = nameFilter;
            if (counterSpin !== undefined)
                this.counterSpin = counterSpin;
        }
        /**
        * Remove the subclass of the event, giving access to all properties, but can allow for invalid data.
        * @returns {AbstractEvent}
        */
        abstract() { return new Event().import(this.json); }
        get speed() { return (0, general_1.jsonGet)(this.json, "_customData._speed"); }
        get direction() { return (0, general_1.jsonGet)(this.json, "_customData._direction"); }
        get nameFilter() { return (0, general_1.jsonGet)(this.json, "_customData._nameFilter"); }
        get reset() { return (0, general_1.jsonGet)(this.json, "_customData._reset"); }
        get rotation() { return (0, general_1.jsonGet)(this.json, "_customData._rotation"); }
        get step() { return (0, general_1.jsonGet)(this.json, "_customData._step"); }
        get prop() { return (0, general_1.jsonGet)(this.json, "_customData._prop"); }
        get counterSpin() { return (0, general_1.jsonGet)(this.json, "_customData._counterSpin"); }
        set speed(value) { (0, general_1.jsonSet)(this.json, "_customData._speed", value); }
        set direction(value) { (0, general_1.jsonSet)(this.json, "_customData._direction", value); }
        set nameFilter(value) { (0, general_1.jsonSet)(this.json, "_customData._nameFilter", value); }
        set reset(value) { (0, general_1.jsonSet)(this.json, "_customData._reset", value); }
        set rotation(value) { (0, general_1.jsonSet)(this.json, "_customData._rotation", value); }
        set step(value) { (0, general_1.jsonSet)(this.json, "_customData._step", value); }
        set prop(value) { (0, general_1.jsonSet)(this.json, "_customData._prop", value); }
        set counterSpin(value) { (0, general_1.jsonSet)(this.json, "_customData._counterSpin", value); }
    }
    EventInternals.RingSpinEvent = RingSpinEvent;
    class RotationEvent extends EventInternals.BaseEvent {
        constructor(json, type, rotation = undefined) {
            super(json);
            this.type = type;
            if (constants_1.EVENT[`CW_${Math.abs(rotation)}`])
                this.value = constants_1.EVENT[`${(rotation < 0 ? "CCW_" : "CW_") + Math.abs(rotation)}`];
            else
                this.rotation = rotation;
        }
        /**
        * Remove the subclass of the event, giving access to all properties, but can allow for invalid data.
        * @returns {AbstractEvent}
        */
        abstract() { return new Event().import(this.json); }
        get rotation() { return (0, general_1.jsonGet)(this.json, "_customData._rotation"); }
        set rotation(value) { (0, general_1.jsonSet)(this.json, "_customData._rotation", value); }
    }
    EventInternals.RotationEvent = RotationEvent;
    class AbstractEvent extends EventInternals.BaseEvent {
        get lockPosition() { return (0, general_1.jsonGet)(this.json, "_customData._lockPosition"); }
        get lightID() { return (0, general_1.jsonGet)(this.json, "_customData._lightID"); }
        get color() { return (0, general_1.jsonGet)(this.json, "_customData._color"); }
        get easing() { return (0, general_1.jsonGet)(this.json, "_customData._easing"); }
        get lerpType() { return (0, general_1.jsonGet)(this.json, "_customData._lerpType"); }
        get lightGradient() { return (0, general_1.jsonGet)(this.json, "_customData._lightGradient"); }
        get startColor() { return (0, general_1.jsonGet)(this.json, "_customData._lightGradient._startColor"); }
        get endColor() { return (0, general_1.jsonGet)(this.json, "_customData._lightGradient._endColor"); }
        get duration() { return (0, general_1.jsonGet)(this.json, "_customData._lightGradient._duration"); }
        get gradientEasing() { return (0, general_1.jsonGet)(this.json, "_customData._lightGradient._easing"); }
        get speed() { return (0, general_1.jsonGet)(this.json, "_customData._speed"); }
        get direction() { return (0, general_1.jsonGet)(this.json, "_customData._direction"); }
        get nameFilter() { return (0, general_1.jsonGet)(this.json, "_customData._nameFilter"); }
        get reset() { return (0, general_1.jsonGet)(this.json, "_customData._reset"); }
        get rotation() { return (0, general_1.jsonGet)(this.json, "_customData._rotation"); }
        get step() { return (0, general_1.jsonGet)(this.json, "_customData._step"); }
        get prop() { return (0, general_1.jsonGet)(this.json, "_customData._prop"); }
        get counterSpin() { return (0, general_1.jsonGet)(this.json, "_customData._counterSpin"); }
        set lockPosition(value) { (0, general_1.jsonSet)(this.json, "_customData._lockPosition", value); }
        set speed(value) { (0, general_1.jsonSet)(this.json, "_customData._speed", value); }
        set direction(value) { (0, general_1.jsonSet)(this.json, "_customData._direction", value); }
        set nameFilter(value) { (0, general_1.jsonSet)(this.json, "_customData._nameFilter", value); }
        set reset(value) { (0, general_1.jsonSet)(this.json, "_customData._reset", value); }
        set rotation(value) { (0, general_1.jsonSet)(this.json, "_customData._rotation", value); }
        set step(value) { (0, general_1.jsonSet)(this.json, "_customData._step", value); }
        set prop(value) { (0, general_1.jsonSet)(this.json, "_customData._prop", value); }
        set counterSpin(value) { (0, general_1.jsonSet)(this.json, "_customData._counterSpin", value); }
        set lightID(value) { (0, general_1.jsonSet)(this.json, "_customData._lightID", value); }
        set color(value) { (0, general_1.jsonSet)(this.json, "_customData._color", value); }
        set easing(value) { (0, general_1.jsonSet)(this.json, "_customData._easing", value); }
        set lerpType(value) { (0, general_1.jsonSet)(this.json, "_customData._lerpType", value); }
        set lightGradient(value) { (0, general_1.jsonSet)(this.json, "_customData._lightGradient", value); }
        set startColor(value) { (0, general_1.jsonSet)(this.json, "_customData._lightGradient._startColor", value); }
        set endColor(value) { (0, general_1.jsonSet)(this.json, "_customData._lightGradient._endColor", value); }
        set duration(value) { (0, general_1.jsonSet)(this.json, "_customData._lightGradient._duration", value); }
        set gradientEasing(value) { (0, general_1.jsonSet)(this.json, "_customData._lightGradient._easing", value); }
    }
    EventInternals.AbstractEvent = AbstractEvent;
})(EventInternals = exports.EventInternals || (exports.EventInternals = {}));
class Event extends EventInternals.BaseEvent {
    /**
     * Event object for ease of creation.
     * @param {Object} time
     */
    constructor(time = 0) { super(time); }
    /**
     * Controls the back lasers.
     * @returns
     */
    backLasers() { return new EventInternals.LightEvent(this.json, constants_1.EVENT.BACK_LASERS); }
    /**
     * Controls the ring lights.
     * @returns
     */
    ringLights() { return new EventInternals.LightEvent(this.json, constants_1.EVENT.RING_LIGHTS); }
    /**
     * Controls the left lasers.
     * @returns
     */
    leftLasers() { return new EventInternals.LightEvent(this.json, constants_1.EVENT.LEFT_LASERS); }
    /**
     * Controls the right lasers.
     * @returns
     */
    rightLasers() { return new EventInternals.LightEvent(this.json, constants_1.EVENT.RIGHT_LASERS); }
    /**
     * Controls the center lasers.
     * @returns
     */
    centerLasers() { return new EventInternals.LightEvent(this.json, constants_1.EVENT.CENTER_LASERS); }
    /**
     * Controls the extra left lasers in some environments.
     * @returns
     */
    extraLeft() { return new EventInternals.LightEvent(this.json, constants_1.EVENT.LEFT_EXTRA); }
    /**
     * Controls the extra right lasers in some environments.
     * @returns
     */
    extraRight() { return new EventInternals.LightEvent(this.json, constants_1.EVENT.RIGHT_EXTRA); }
    /**
     * Controls the left lasers in the Billie environment.
     * @returns
     */
    billieLeft() { return new EventInternals.LightEvent(this.json, constants_1.EVENT.BILLIE_LEFT); }
    /**
     * Controls the right lasers in the Billie environment.
     * @returns
     */
    billieRight() { return new EventInternals.LightEvent(this.json, constants_1.EVENT.BILLIE_RIGHT); }
    /**
     * Create an event using JSON.
     * @param {Object} json
     * @returns {AbstractEvent}
     */
    import(json) { return new EventInternals.AbstractEvent(json); }
    /**
     * Create an event with no particular identity.
    * @returns {AbstractEvent};
    */
    abstract() { return this.import({}); }
    /**
     * Make this event change boost colors.
     * @param {Boolean} on
     * @returns
     */
    boost(on) {
        this.type = constants_1.EVENT.BOOST;
        this.value = on ? constants_1.EVENT.BOOST_ON : constants_1.EVENT.BOOST_OFF;
        return new EventInternals.BaseEvent(this.json);
    }
    /**
     * Move cars in the interscope environment.
     * @param {Number} value
     * @returns
     */
    moveCars(value) {
        this.type = constants_1.EVENT.RING_SPIN;
        this.value = value;
        return new EventInternals.BaseEvent(this.json);
    }
    /**
     * Lower the hydraulics of the cars in the interscope environment.
     * @returns
     */
    lowerHydraulics() {
        this.type = constants_1.EVENT.LOWER_HYDRAULICS;
        return new EventInternals.BaseEvent(this.json);
    }
    /**
     * Raise the hydraulics of the cars in the interscope environment.
     * @returns
     */
    raiseHydraulics() {
        this.type = constants_1.EVENT.RAISE_HYDRAULICS;
        return new EventInternals.BaseEvent(this.json);
    }
    /**
     * Spin the rings in an environment.
     * @param {Number} rotation
     * @param {Number} direction
     * @param {Number} step
     * @param {Number} speed
     * @param {Number} prop
     * @param {Boolean} reset
     * @param {String} nameFilter
     * @param {Boolean} counterSpin
     * @returns
     */
    ringSpin(rotation = undefined, direction = undefined, step = undefined, speed = undefined, prop = undefined, reset = undefined, nameFilter = undefined, counterSpin = undefined) {
        return new EventInternals.RingSpinEvent(this.json, rotation, direction, step, speed, prop, reset, nameFilter, counterSpin);
    }
    /**
     * Control the zoom of the rings.
     * @param {Number} step
     * @param {Number} speed
     * @returns
     */
    ringZoom(step = undefined, speed = undefined) { return new EventInternals.RingZoomEvent(this.json, step, speed); }
    /**
     * Control the movement speed of the left lasers.
     * @param {Number} speed When containing decimals, the noodle data will be used for speed.
     * @param {Number} direction
     * @param {Boolean} lockPosition
     * @returns
     */
    leftLaserSpeed(speed, direction = undefined, lockPosition = undefined) {
        return new EventInternals.LaserSpeedEvent(this.json, constants_1.EVENT.LEFT_SPEED, speed, direction, lockPosition);
    }
    /**
     * Control the movement speed of the right lasers.
     * @param {Number} speed When containing decimals, the noodle data will be used for speed.
     * @param {Number} direction
     * @param {Boolean} lockPosition
     * @returns
     */
    rightLaserSpeed(speed, direction = undefined, lockPosition = undefined) {
        return new EventInternals.LaserSpeedEvent(this.json, constants_1.EVENT.RIGHT_SPEED, speed, direction, lockPosition);
    }
    /**
     * Used for 360 mode, rotates future objects and active objects.
     * @param {Number} rotation
     * @returns
     */
    earlyRotation(rotation) { return new EventInternals.RotationEvent(this.json, constants_1.EVENT.EARLY_ROTATION, rotation); }
    /**
     * Used for 360 mode, rotates future objects only.
     * @param {Number} rotation
     * @returns
     */
    lateRotation(rotation) { return new EventInternals.RotationEvent(this.json, constants_1.EVENT.LATE_ROTATION, rotation); }
}
exports.Event = Event;
