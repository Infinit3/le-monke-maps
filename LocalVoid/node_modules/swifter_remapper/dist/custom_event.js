"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomEvent = exports.CustomEventInternals = void 0;
const general = __importStar(require("./general"));
const beatmap_1 = require("./beatmap");
const animation_1 = require("./animation");
var CustomEventInternals;
(function (CustomEventInternals) {
    class BaseEvent {
        constructor(time) {
            this.json = {
                _time: 0,
                _type: "",
                _data: {}
            };
            if (typeof time === "object") {
                Object.assign(this.json, time);
                return;
            }
            this.time = time;
        }
        /**
        * Push this event to the difficulty
        */
        push() {
            if (beatmap_1.activeDiff.customEvents === undefined)
                beatmap_1.activeDiff.customEvents = [];
            beatmap_1.activeDiff.customEvents.push(general.copy(this));
            return this;
        }
        get time() { return this.json._time; }
        get type() { return this.json._type; }
        get data() { return this.json._data; }
        set time(value) { this.json._time = value; }
        set type(value) { this.json._type = value; }
        set data(value) { this.json._data = value; }
    }
    CustomEventInternals.BaseEvent = BaseEvent;
    class AnimateTrack extends BaseEvent {
        constructor(json, track, duration, animation, easing) {
            super(json);
            this.trackSet = track;
            this.duration = duration;
            this.type = "AnimateTrack";
            this.setProperties(animation);
            this.animate = new animation_1.Animation().abstract(this.data);
            if (easing !== undefined)
                this.easing = easing;
        }
        /**
         * Set the properties for animation.
         * @param data
         */
        setProperties(data) {
            let oldData = general.copy(this.data);
            Object.keys(this.data).forEach(key => { delete this.data[key]; });
            this.trackSet = oldData._track;
            this.duration = oldData._duration;
            if (oldData._easing)
                this.easing = oldData._easing;
            Object.keys(data).forEach(x => {
                this.json._data[x] = data[x];
            });
        }
        /**
         * Apply an animation through the Animation class.
         * @param {Animation} animation
         */
        importAnimation(animation) {
            this.setProperties(animation.json);
            this.duration = animation.length;
            this.animate.length = animation.length;
            return this;
        }
        /**
        * Remove the subclass of the event, giving access to all properties, but can allow for invalid data.
        * @returns {AbstractEvent}
        */
        abstract() { return new CustomEvent().import(this.json); }
        get track() { return new animation_1.Track(this.data._track); }
        get duration() { return this.data._duration; }
        get easing() { return this.data._easing; }
        set trackSet(value) { this.data._track = value; }
        set duration(value) { this.data._duration = value; }
        set easing(value) { this.data._easing = value; }
    }
    CustomEventInternals.AnimateTrack = AnimateTrack;
    class AssignPathAnimation extends BaseEvent {
        constructor(json, track, duration, animation, easing) {
            super(json);
            this.type = "AssignPathAnimation";
            this.trackSet = track;
            this.duration = duration;
            this.setProperties(animation);
            this.animate = new animation_1.Animation().abstract(this.data);
            if (easing !== undefined)
                this.easing = easing;
        }
        /**
         * Set the properties for animation.
         * @param data
         */
        setProperties(data) {
            let oldData = general.copy(this.data);
            Object.keys(this.data).forEach(key => { delete this.data[key]; });
            this.trackSet = oldData._track;
            this.duration = oldData._duration;
            if (oldData._easing)
                this.easing = oldData._easing;
            Object.keys(data).forEach(x => {
                this.json._data[x] = data[x];
            });
        }
        /**
         * Apply an animation through the Animation class.
         * @param {Animation} animation
         */
        importAnimation(animation) {
            this.setProperties(animation.json);
            this.duration = animation.length;
            this.animate.length = animation.length;
            return this;
        }
        /**
        * Remove the subclass of the event, giving access to all properties, but can allow for invalid data.
        * @returns {AbstractEvent}
        */
        abstract() { return new CustomEvent().import(this.json); }
        get track() { return new animation_1.Track(this.data._track); }
        get duration() { return this.data._duration; }
        get easing() { return this.data._easing; }
        set trackSet(value) { this.data._track = value; }
        set duration(value) { this.data._duration = value; }
        set easing(value) { this.data._easing = value; }
    }
    CustomEventInternals.AssignPathAnimation = AssignPathAnimation;
    class AssignTrackParent extends BaseEvent {
        constructor(json, childrenTracks, parentTrack, worldPositionStays) {
            super(json);
            this.type = "AssignTrackParent";
            this.childrenTracks = childrenTracks;
            this.parentTrack = parentTrack;
            if (worldPositionStays !== undefined)
                this.worldPositionStays = worldPositionStays;
        }
        /**
        * Remove the subclass of the event, giving access to all properties, but can allow for invalid data.
        * @returns {AbstractEvent}
        */
        abstract() { return new CustomEvent().import(this.json); }
        get childrenTracks() { return this.data._childrenTracks; }
        get parentTrack() { return this.data._parentTrack; }
        get worldPositionStays() { return this.data._worldPositionStays; }
        set childrenTracks(value) { this.data._childrenTracks = value; }
        set parentTrack(value) { this.data._parentTrack = value; }
        set worldPositionStays(value) { this.data._worldPositionStays = value; }
    }
    CustomEventInternals.AssignTrackParent = AssignTrackParent;
    class AssignPlayerToTrack extends BaseEvent {
        constructor(json, track) {
            super(json);
            this.type = "AssignPlayerToTrack";
            this.trackSet = track;
        }
        /**
        * Remove the subclass of the event, giving access to all properties, but can allow for invalid data.
        * @returns {AbstractEvent}
        */
        abstract() { return new CustomEvent().import(this.json); }
        get track() { return new animation_1.Track(this.data._track); }
        set trackSet(value) { this.data._track = value; }
    }
    CustomEventInternals.AssignPlayerToTrack = AssignPlayerToTrack;
    class AssignFogTrack extends BaseEvent {
        constructor(json, track) {
            super(json);
            this.type = "AssignFogTrack";
            this.trackSet = track;
        }
        /**
        * Remove the subclass of the event, giving access to all properties, but can allow for invalid data.
        * @returns {AbstractEvent}
        */
        abstract() { return new CustomEvent().import(this.json); }
        get track() { return new animation_1.Track(this.data._track); }
        set trackSet(value) { this.data._track = value; }
    }
    CustomEventInternals.AssignFogTrack = AssignFogTrack;
    class AbstractEvent extends BaseEvent {
        constructor(json) {
            super(json);
            this.animate = new animation_1.Animation().abstract(this.data);
        }
        /**
         * Add properties to the data.
         * @param data
         */
        appendData(data) {
            Object.keys(data).forEach(x => {
                this.json._data[x] = data[x];
            });
        }
        /**
         * Apply an animation through the Animation class.
         * @param {Animation} animation
         */
        importAnimation(animation) {
            this.appendData(animation.json);
            this.duration = animation.length;
            this.animate.length = animation.length;
            return this;
        }
        get track() { return new animation_1.Track(this.data._track); }
        get duration() { return this.data._duration; }
        get easing() { return this.data._easing; }
        get childrenTracks() { return this.data._childrenTracks; }
        get parentTrack() { return this.data._parentTrack; }
        get worldPositionStays() { return this.data._worldPositionStays; }
        set trackSet(value) { this.data._track = value; }
        set duration(value) { this.data._duration = value; }
        set easing(value) { this.data._easing = value; }
        set childrenTracks(value) { this.data._childrenTracks = value; }
        set parentTrack(value) { this.data._parentTrack = value; }
        set worldPositionStays(value) { this.data._worldPositionStays = value; }
    }
    CustomEventInternals.AbstractEvent = AbstractEvent;
})(CustomEventInternals = exports.CustomEventInternals || (exports.CustomEventInternals = {}));
class CustomEvent extends CustomEventInternals.BaseEvent {
    /**
     * Event object for ease of creation.
     * @param {Object} time
     */
    constructor(time = 0) { super(time); }
    /**
     * Create a custom event using JSON.
     * @param {Object} json
     * @returns {AbstractEvent}
     */
    import(json) { return new CustomEventInternals.AbstractEvent(json); }
    /**
     * Create an event with no particular identity.
     * @returns {AbstractEvent};
     */
    abstract() { return this.import({}); }
    /**
     * Animate a track.
     * @param {String} track
     * @param {Number} duration
     * @param {Object} animation JSON for the animation.
     * @param {String} easing
     * @returns
     */
    animateTrack(track, duration = undefined, animation = {}, easing = undefined) {
        duration !== null && duration !== void 0 ? duration : (duration = 0);
        animation !== null && animation !== void 0 ? animation : (animation = {});
        return new CustomEventInternals.AnimateTrack(this.json, track, duration, animation, easing);
    }
    /**
     * Animate objects on a track across their lifespan.
     * @param {String} track
     * @param {Number} duration
     * @param {Object} animation JSON for the animation.
     * @param {String} easing
     * @returns
     */
    assignPathAnimation(track, duration = undefined, animation = {}, easing = undefined) {
        duration !== null && duration !== void 0 ? duration : (duration = 0);
        animation !== null && animation !== void 0 ? animation : (animation = {});
        return new CustomEventInternals.AssignPathAnimation(this.json, track, duration, animation, easing);
    }
    /**
     * Assign a parent to a track.
     * @param {Array} childrenTracks
     * @param {String} parentTrack
     * @param {Boolean} worldPositionStays Object stays in the same place after being parented, false by default.
     * @returns
     */
    assignTrackParent(childrenTracks, parentTrack, worldPositionStays = undefined) {
        return new CustomEventInternals.AssignTrackParent(this.json, childrenTracks, parentTrack, worldPositionStays);
    }
    /**
     * Assign the player to a track.
     * @param {String} track
     * @returns
     */
    assignPlayerToTrack(track) { return new CustomEventInternals.AssignPlayerToTrack(this.json, track); }
    /**
     * Assign the fog to a track.
     * @param {String} track
     * @returns
     */
    assignFogTrack(track) { return new CustomEventInternals.AssignFogTrack(this.json, track); }
}
exports.CustomEvent = CustomEvent;
