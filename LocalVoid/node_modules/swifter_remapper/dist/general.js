"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.debugWall = exports.worldToWall = exports.getJumps = exports.jsonRemove = exports.jsonCheck = exports.jsonSet = exports.jsonGet = exports.jsonPrune = exports.toDegrees = exports.toRadians = exports.rotateVector = exports.rotatePoint = exports.isEmptyObject = exports.copy = exports.clamp = exports.round = exports.rand = exports.arrEqual = exports.arrDiv = exports.arrMul = exports.arrAdd = exports.arrLast = exports.findFraction = exports.lerpEasing = exports.lerpRotation = exports.lerpWrap = exports.lerp = exports.eventsBetween = exports.wallsBetween = exports.notesBetween = exports.sortObjects = exports.filterObjects = void 0;
const EPSILON = 1e-3;
const jseasingfunctions = __importStar(require("js-easing-functions"));
const animation_1 = require("./animation");
const wall_1 = require("./wall");
const three = __importStar(require("three"));
const constants_1 = require("./constants");
const beatmap_1 = require("./beatmap");
/**
 * Allows you to filter through an array of objects with a min and max property.
 * @param {Number} min
 * @param {Number} max
 * @param {Array} objects Array of objects to check.
 * @param {String} property What property to check for.
 * @returns {Array}
 */
function filterObjects(objects, min, max, property) {
    let passedObjects = [];
    objects.forEach(obj => {
        if (obj[property] + EPSILON >= min && obj[property] + EPSILON < max)
            passedObjects.push(obj);
    });
    return passedObjects;
}
exports.filterObjects = filterObjects;
/**
 * Sorts an array of objects by a property.
 * @param {Array} objects Array of objects to sort.
 * @param {String} property What property to sort.
 * @param {Boolean} smallestToLargest Whether to sort smallest to largest. True by default.
 */
function sortObjects(objects, property, smallestToLargest = true) {
    if (objects === undefined)
        return;
    objects.sort((a, b) => smallestToLargest ?
        a[property] - b[property] :
        b[property] - a[property]);
}
exports.sortObjects = sortObjects;
/**
 * Gets notes between a min and max time, as a Note class.
 * @param {Number} min
 * @param {Number} max
 * @param {Function} forEach Lambda function for each note.
 * @returns {Array}
 */
function notesBetween(min, max, forEach) {
    filterObjects(beatmap_1.activeDiff.notes, min, max, "time").forEach(x => { forEach(x); });
}
exports.notesBetween = notesBetween;
/**
 * Gets walls between a min and max time, as a Wall class.
 * @param {Number} min
 * @param {Number} max
 * @param {Function} forEach Lambda function for each wall.
 * @returns {Array}
 */
function wallsBetween(min, max, forEach) {
    filterObjects(beatmap_1.activeDiff.obstacles, min, max, "time").forEach(x => { forEach(x); });
}
exports.wallsBetween = wallsBetween;
/**
 * Gets events between a min and max time, as an Event class.
 * @param {Number} min
 * @param {Number} max
 * @param {Function} forEach Lambda function for each event.
 * @returns {Array}
 */
function eventsBetween(min, max, forEach) {
    filterObjects(beatmap_1.activeDiff.events, min, max, "time").forEach(x => { forEach(x); });
}
exports.eventsBetween = eventsBetween;
/**
 * Interpolates between a start and end value to get a value in between.
 * @param {Number} start
 * @param {Number} end
 * @param {Number} fraction
 * @param {String} easing Optional easing
 * @returns {Number}
 */
function lerp(start, end, fraction, easing = undefined) {
    if (easing !== undefined)
        fraction = lerpEasing(easing, fraction);
    return start + (end - start) * fraction;
}
exports.lerp = lerp;
/**
 * Interpolates between a start and end value to get a value in between. Will wrap around 0-1.
 * @param {Number} start
 * @param {Number} end
 * @param {Number} fraction
 * @param {String} easing Optional easing
 * @returns
 */
function lerpWrap(start, end, fraction, easing = undefined) {
    if (easing !== undefined)
        fraction = lerpEasing(easing, fraction);
    let distance = Math.abs(end - start);
    if (distance <= 0.5)
        return lerp(start, end, fraction);
    else {
        if (end > start)
            start += 1;
        else
            start -= 1;
        let result = lerp(start, end, fraction);
        if (result < 0)
            result = 1 + result;
        return result % 1;
    }
}
exports.lerpWrap = lerpWrap;
/**
 * Interpolates between a start and end rotation to get a rotation in between.
 * @param {Vec3} start
 * @param {Vec3} end
 * @param {Number} fraction
 * @param {EASE} easing
 * @returns
 */
function lerpRotation(start, end, fraction, easing = undefined) {
    if (easing !== undefined)
        fraction = lerpEasing(easing, fraction);
    let q1 = new three.Quaternion().setFromEuler(new three.Euler(...toRadians(start), "YXZ"));
    let q2 = new three.Quaternion().setFromEuler(new three.Euler(...toRadians(end), "YXZ"));
    q1.slerp(q2, fraction);
    let output = toDegrees(new three.Euler().reorder("YXZ").setFromQuaternion(q1).toArray());
    output.pop();
    return output;
}
exports.lerpRotation = lerpRotation;
/**
 * Process a number through an easing.
 * @param {String} easing Name of easing.
 * @param {Number} value Progress of easing (0-1).
 * @returns {Number}
 */
function lerpEasing(easing, value) {
    if (easing === "easeLinear" || easing === undefined)
        return value;
    if (easing === "easeStep")
        return value === 1 ? 1 : 0;
    return jseasingfunctions[easing](value, 0, 1, 1);
}
exports.lerpEasing = lerpEasing;
/**
 * Find value between 0 and 1 from a beginning, length, and a point in time between.
 * @param {Number} beginning
 * @param {Number} length
 * @param {Number} time
 * @returns {Number}
 */
function findFraction(beginning, length, time) {
    if (length === 0)
        return 0;
    return (time - beginning) / length;
}
exports.findFraction = findFraction;
/**
 * Get the last element in an array.
 * @param {Array} arr
 * @returns {*}
 */
function arrLast(arr) {
    return arr[arr.length - 1];
}
exports.arrLast = arrLast;
/**
 * Add either a number or another array to an array.
 * @param {Array} arr
 * @param {*} value Can be a number or an array.
 * @returns {Array}
 */
function arrAdd(arr, value) {
    if (typeof value === "number")
        return arr.map(x => x + value);
    else
        return arr.map((x, i) => x + (value[i] !== undefined ? value[i] : 0));
}
exports.arrAdd = arrAdd;
/**
 * Multiply an array either by a number or another array.
 * @param {Array} arr
 * @param {*} value Can be a number or an array.
 * @returns {Array}
 */
function arrMul(arr, value) {
    if (typeof value === "number")
        return arr.map(x => x * value);
    else
        return arr.map((x, i) => x * (value[i] !== undefined ? value[i] : 1));
}
exports.arrMul = arrMul;
/**
 * Divide an array either by a number or another array.
 * @param {Array} arr
 * @param {*} value Can be a number or an array.
 * @returns {Array}
 */
function arrDiv(arr, value) {
    if (typeof value === "number")
        return arr.map(x => x / value);
    else
        return arr.map((x, i) => x / (value[i] !== undefined ? value[i] : 1));
}
exports.arrDiv = arrDiv;
/**
 * Check if 2 arrays are equal to each other.
 * @param {Array} arr1
 * @param {Array} arr2
 * @param {Number} lenience The maximum difference 2 numbers in an array can have before they're considered not equal.
 * @returns {Boolean}
 */
function arrEqual(arr1, arr2, lenience = 0) {
    if (!arr1 || !arr2)
        return false;
    if (arr1.length !== arr2.length)
        return false;
    let result = true;
    arr1.forEach((x, i) => {
        if (lenience !== 0 && typeof x === "number" && typeof arr2[i] === "number") {
            let difference = x - arr2[i];
            if (Math.abs(difference) > lenience)
                result = false;
        }
        else if (x !== arr2[i])
            result = false;
    });
    return result;
}
exports.arrEqual = arrEqual;
/**
 * Gives a random number in the given range.
 * @param {Number} start
 * @param {Number} end
 * @returns {Number}
 */
function rand(start, end) {
    return (Math.random() * (end - start)) + start;
}
exports.rand = rand;
/**
 * Rounds a number to the nearest other number.
 * @param {Number} input
 * @param {Number} number
 * @returns {Number}
 */
function round(input, number) {
    return Math.round(input / number) * number;
}
exports.round = round;
/**
 * Makes a number fit between a min and max value.
 * @param {Number} input
 * @param {Number} min Can be left undefined to ignore.
 * @param {Number} max Can be left undefined to ignore.
 * @returns {Number}
 */
function clamp(input, min = undefined, max = undefined) {
    if (max !== undefined && input > max)
        input = max;
    else if (min !== undefined && input < min)
        input = min;
    return input;
}
exports.clamp = clamp;
/**
 * Creates a new instance of an object.
 * @param {*} obj
 * @returns
 */
function copy(obj) {
    if (obj == null || typeof obj !== "object") {
        return obj;
    }
    let newObj = Array.isArray(obj) ? [] : {};
    let keys = Object.getOwnPropertyNames(obj);
    keys.forEach(x => {
        let value = copy(obj[x]);
        newObj[x] = value;
    });
    Object.setPrototypeOf(newObj, obj.__proto__);
    return newObj;
}
exports.copy = copy;
/**
 * Checks if an object is empty.
 * @param {Object} o
 * @returns {Boolean}
 */
function isEmptyObject(o) {
    if (typeof o !== "object")
        return false;
    return Object.keys(o).length === 0;
}
exports.isEmptyObject = isEmptyObject;
/**
 * Rotate a point around 0,0,0.
 * @param {Array} rotation
 * @param {Array} point
 * @param {Array} anchor Anchor of rotation.
 * @returns {Array}
 */
function rotatePoint(rotation, point, anchor = [0, 0, 0]) {
    let mathRot = toRadians(rotation);
    let vector = new three.Vector3(...arrAdd(point, arrMul(anchor, -1))).applyEuler(new three.Euler(...mathRot, "YXZ"));
    return arrAdd([vector.x, vector.y, vector.z], anchor);
}
exports.rotatePoint = rotatePoint;
/**
 * Rotate a vector, starts downwards.
 * @param {Array} rotation
 * @param {Number} length
 * @returns {Array}
 */
function rotateVector(rotation, length) {
    return rotatePoint(rotation, [0, -length, 0]);
}
exports.rotateVector = rotateVector;
/**
 * Convert an array of numbers from degrees to radians.
 * @param {Array} values
 * @returns
 */
function toRadians(values) {
    return values.map(x => x * (Math.PI / 180));
}
exports.toRadians = toRadians;
/**
 * Convert an array of numbers from radians to degrees.
 * @param {Array} values
 * @returns
 */
function toDegrees(values) {
    return values.map(x => x * (180 / Math.PI));
}
exports.toDegrees = toDegrees;
/**
 * Delete empty objects/arrays from an object recursively.
 * @param {Object} obj
 */
function jsonPrune(obj) {
    for (let prop in obj) {
        const type = typeof obj[prop];
        if (type === "object") {
            if (Array.isArray(obj[prop])) {
                if (obj[prop].length === 0) {
                    delete obj[prop];
                }
            }
            else {
                jsonPrune(obj[prop]);
                if (isEmptyObject(obj[prop])) {
                    delete obj[prop];
                }
            }
        }
        else if (type === "string" && obj[prop].length === 0) {
            delete obj[prop];
        }
        if (type === "undefined")
            delete obj[prop];
    }
}
exports.jsonPrune = jsonPrune;
/**
* Get a property of an object.
* @param {Object} obj
* @param {String} prop
* @param {*} init Optional value to initialize the property if it doesn't exist yet.
*/
function jsonGet(obj, prop) {
    const steps = prop.split('.');
    let currentObj = obj;
    for (let i = 0; i < steps.length - 1; i++) {
        currentObj = currentObj[steps[i]];
        if (currentObj === undefined)
            return;
    }
    return currentObj[steps[steps.length - 1]];
}
exports.jsonGet = jsonGet;
/**
 * Set a property in an object, add objects if needed.
 * @param {Object} obj
 * @param {String} prop
 * @param {*} value
 */
function jsonSet(obj, prop, value) {
    const steps = prop.split('.');
    let currentObj = obj;
    for (let i = 0; i < steps.length - 1; i++) {
        if (!(steps[i] in currentObj)) {
            currentObj[steps[i]] = {};
        }
        currentObj = currentObj[steps[i]];
    }
    currentObj[steps[steps.length - 1]] = value;
}
exports.jsonSet = jsonSet;
/**
 * Check if a property in an object exists
 * @param {Object} obj
 * @param {String} prop
 * @returns {Boolean}
 */
function jsonCheck(obj, prop) {
    let value = jsonGet(obj, prop);
    if (value !== undefined)
        return true;
    return false;
}
exports.jsonCheck = jsonCheck;
/**
* Remove a property of an object recursively, and delete empty objects left behind.
* @param {Object} obj
* @param {String} prop
*/
function jsonRemove(obj, prop) {
    const steps = prop.split('.');
    let currentObj = obj;
    for (let i = 0; i < steps.length - 1; i++) {
        currentObj = currentObj[steps[i]];
        if (currentObj === undefined)
            return;
    }
    delete currentObj[steps[steps.length - 1]];
}
exports.jsonRemove = jsonRemove;
/**
 * Get jump related info.
 * @param {Number} NJS
 * @param {Number} offset
 * @param {Number} BPM
 * @returns {Object} Returns an object; {halfDur, dist}.
 * A "jump" is the period when the object "jumps" in (indicated by spawning light on notes) to when it's deleted.
 * Jump Duration is the time in beats that the object will be jumping for.
 * This function will output half of this, so it will end when the note is supposed to be hit.
 * Jump Distance is the Z distance from when the object starts it's jump to when it's deleted.
 * This function will output the jump distance converted to noodle units.
 */
function getJumps(NJS, offset, BPM) {
    const startHJD = 4;
    const maxHJD = 18;
    let num = 60 / BPM;
    let num2 = startHJD;
    while (NJS * num * num2 > maxHJD)
        num2 /= 2;
    num2 += offset;
    if (num2 < 1)
        num2 = 1;
    let jumpDur = num * num2 * 2;
    let jumpDist = NJS * jumpDur;
    jumpDist /= 0.6;
    return { halfDur: num2, dist: jumpDist };
}
exports.getJumps = getJumps;
/**
 * Calculate the correct position for a wall to line up with a position in the world.
 * @param {Array} pos
 * @param {Array} rot
 * @param {Array} scale
 * @returns
 */
function worldToWall(pos, rot, scale) {
    let wallOffset = [0, -0.5, -0.5];
    let offset = rotatePoint(rot, scale.map((y, i) => y * wallOffset[i]));
    pos = pos.map((y, i) => y + offset[i]);
    pos[0] -= 0.5;
    pos[1] -= 0.1 / 0.6;
    pos[2] -= 0.65 / 0.6;
    return pos;
}
exports.worldToWall = worldToWall;
/**
 * Create a wall for debugging. Position, rotation, and scale are in world space and can be animations.
 * @param {Array} pos
 * @param {Array} rot
 * @param {Array} scale
 * @param {Number} animStart When animation starts.
 * @param {Number} animDur How long animation lasts for.
 * @param {Number} animFreq Frequency of keyframes in animation.
 */
function debugWall(pos = undefined, rot = undefined, scale = undefined, animStart = undefined, animDur = undefined, animFreq = 1 / 8) {
    pos !== null && pos !== void 0 ? pos : (pos = [0, 0, 0]);
    rot !== null && rot !== void 0 ? rot : (rot = [0, 0, 0]);
    scale !== null && scale !== void 0 ? scale : (scale = [1, 1, 1]);
    animStart !== null && animStart !== void 0 ? animStart : (animStart = 0);
    animDur !== null && animDur !== void 0 ? animDur : (animDur = 0);
    let wall = new wall_1.Wall();
    wall.life = animDur + 69420;
    wall.lifeStart = 0;
    let wallAnim = new animation_1.Animation(wall.life).wallAnimation();
    let dataAnim = new animation_1.Animation().wallAnimation();
    dataAnim.position = copy(pos);
    dataAnim.rotation = copy(rot);
    dataAnim.scale = copy(scale);
    let data = {
        pos: [],
        rot: [],
        scale: []
    };
    function getDomain(arr) {
        arr = (0, animation_1.complexifyArray)(arr);
        arr = arr.sort((a, b) => new animation_1.Keyframe(a).time - new animation_1.Keyframe(b).time);
        let min = 1;
        let max = 0;
        arr.forEach(x => {
            let time = new animation_1.Keyframe(x).time;
            if (time < min)
                min = time;
            if (time > max)
                max = time;
        });
        return { min: min, max: max };
    }
    let posDomain = getDomain(pos);
    let rotDomain = getDomain(rot);
    let scaleDomain = getDomain(scale);
    let totalMin = getDomain([[posDomain.min], [rotDomain.min], [scaleDomain.min]]).min;
    let totalMax = getDomain([[posDomain.max], [rotDomain.max], [scaleDomain.max]]).max;
    for (let i = totalMin; i <= totalMax; i += animFreq / animDur) {
        let time = i * animDur + animStart;
        let objPos = dataAnim.get(constants_1.ANIM.POSITION, i);
        let objRot = dataAnim.get(constants_1.ANIM.ROTATION, i);
        let objScale = dataAnim.get(constants_1.ANIM.SCALE, i);
        objPos = worldToWall(objPos, objRot, objScale);
        data.pos.push([...objPos, time]);
        data.rot.push([...objRot, time]);
        data.scale.push([...objScale, time]);
    }
    wallAnim.definitePosition = data.pos;
    wallAnim.localRotation = data.rot;
    wallAnim.scale = data.scale;
    wallAnim.optimize();
    wall.color = [0, 0, 0, 1];
    wall.importAnimation(wallAnim);
    wall.push();
}
exports.debugWall = debugWall;
