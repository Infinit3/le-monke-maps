import { EASE, SPLINE } from "./constants";
import { Vec3, Vec4 } from "./general";
export declare type Interpolation = EASE | SPLINE;
export declare type KeyframesLinear = [number] | [number, number, Interpolation?, SPLINE?][] | string;
export declare type KeyframesVec3 = Vec3 | [...Vec3, number, Interpolation?, SPLINE?][] | string;
export declare type KeyframesVec4 = Vec4 | [...Vec4, number, Interpolation?, SPLINE?][] | string;
export declare type KeyframesAny = number[] | KeyframeValues[] | string;
export declare type KeyframeValues = (number | EASE | SPLINE)[];
export declare type KeyframeArray = KeyframeValues[];
export declare type TrackValue = string | string[];
export declare namespace AnimationInternals {
    export class BaseAnimation {
        json: any;
        length: any;
        constructor(length?: number, data?: any);
        /**
         * Clear animation data. Leave blank to completely clear animation.
         */
        clear(property?: string): void;
        /**
         * Set a property's animations. Does not edit the value.
         * @param {String} property
         * @param {*} value
         */
        set(property: string, value: any): void;
        /**
         * Get a property's animations.
         * @param {String} property
         * @param {Number} time Option to get the values of a property at a certain time. Does not account for splines.
         * Time can be in length of animation or between 0 and 1 if negative.
         * @returns {*}
         */
        get(property: string, time?: number): any;
        /**
         * Add animations to a property, also sorts by time and makes optimizations if possible.
         * @param {String} property
         * @param {*} value
         */
        add(property: string, value: any): void;
        /**
         * Remove similar values to cut down on keyframe count.
         * @param {Number} accuracy Multiplier for the max difference that values are considered "similar".
         * @param {String} property Optimize only a single property, or set to undefined to optimize all.
         */
        optimize(accuracy?: number, property?: string): void;
        private convert;
        private convertTime;
    }
    class ObjectAnimation extends BaseAnimation {
        get position(): KeyframesVec3;
        get definitePosition(): KeyframesVec3;
        get rotation(): KeyframesVec3;
        get localRotation(): KeyframesVec3;
        get scale(): KeyframesVec3;
        get dissolve(): KeyframesLinear;
        get color(): KeyframesVec4;
        get interactable(): KeyframesLinear;
        get time(): KeyframesLinear;
        set position(value: KeyframesVec3);
        set definitePosition(value: KeyframesVec3);
        set rotation(value: KeyframesVec3);
        set localRotation(value: KeyframesVec3);
        set scale(value: KeyframesVec3);
        set dissolve(value: KeyframesLinear);
        set color(value: KeyframesVec4);
        set interactable(value: KeyframesLinear);
        set time(value: KeyframesLinear);
    }
    export class NoteAnimation extends ObjectAnimation {
        get dissolveArrow(): KeyframesLinear;
        set dissolveArrow(value: KeyframesLinear);
    }
    export class WallAnimation extends ObjectAnimation {
    }
    export class EnvironmentAnimation extends BaseAnimation {
        get position(): KeyframesVec3;
        get rotation(): KeyframesVec3;
        get localPosition(): KeyframesVec3;
        get localRotation(): KeyframesVec3;
        get scale(): KeyframesVec3;
        set position(value: KeyframesVec3);
        set rotation(value: KeyframesVec3);
        set localPosition(value: KeyframesVec3);
        set localRotation(value: KeyframesVec3);
        set scale(value: KeyframesVec3);
    }
    export class FogAnimation extends BaseAnimation {
        get attenuation(): KeyframesLinear;
        get offset(): KeyframesLinear;
        get startY(): KeyframesLinear;
        get height(): KeyframesLinear;
        set attenuation(value: KeyframesLinear);
        set offset(value: KeyframesLinear);
        set startY(value: KeyframesLinear);
        set height(value: KeyframesLinear);
    }
    export class AbstractAnimation extends ObjectAnimation {
        get position(): KeyframesVec3;
        get localPosition(): KeyframesVec3;
        get definitePosition(): KeyframesVec3;
        get rotation(): KeyframesVec3;
        get localRotation(): KeyframesVec3;
        get scale(): KeyframesVec3;
        get dissolve(): KeyframesLinear;
        get dissolveArrow(): KeyframesLinear;
        get color(): KeyframesVec4;
        get interactable(): KeyframesLinear;
        get time(): KeyframesLinear;
        get attenuation(): KeyframesLinear;
        get offset(): KeyframesLinear;
        get startY(): KeyframesLinear;
        get height(): KeyframesLinear;
        set position(value: KeyframesVec3);
        set localPosition(value: KeyframesVec3);
        set definitePosition(value: KeyframesVec3);
        set rotation(value: KeyframesVec3);
        set localRotation(value: KeyframesVec3);
        set scale(value: KeyframesVec3);
        set dissolve(value: KeyframesLinear);
        set dissolveArrow(value: KeyframesLinear);
        set color(value: KeyframesVec4);
        set interactable(value: KeyframesLinear);
        set time(value: KeyframesLinear);
        set attenuation(value: KeyframesLinear);
        set offset(value: KeyframesLinear);
        set startY(value: KeyframesLinear);
        set height(value: KeyframesLinear);
    }
    export {};
}
export declare class Animation extends AnimationInternals.BaseAnimation {
    /**
    * Noodle animation manager.
    * The time in each keyframe is divided by the length.
    * Use a negative number or don't specify a length to use a range between 0 and 1.
    * Setting a property will add any existing keyframes and sort by time.
    * @param {Number} length
    */
    constructor(length?: number);
    /**
    * Create an animation using JSON.
    * @param {Object} json
    * @returns {AbstractAnimation}
    */
    import(json: object): AnimationInternals.AbstractAnimation;
    /**
     * Create an event with no particular identity.
     * @returns {AbstractAnimation};
     */
    abstract(json?: object): AnimationInternals.AbstractAnimation;
    /**
     * State that this animation is for a note.
     * @param {Object} json
     * @returns
     */
    noteAnimation(json?: object): AnimationInternals.NoteAnimation;
    /**
     * State that this animation is for a wall.
     * @param {Object} json
     * @returns
     */
    wallAnimation(json?: object): AnimationInternals.WallAnimation;
    /**
     * State that this animation is for an environment object.
     * @param {Object} json
     * @returns
     */
    environmentAnimation(json?: object): AnimationInternals.EnvironmentAnimation;
    /**
     * State that this animation is for fog.
     * @param {Object} json
     * @returns
     */
    fogAnimation(json?: object): AnimationInternals.FogAnimation;
}
export declare class Keyframe {
    values: number[];
    timeIndex: number;
    time: number;
    easing: EASE;
    spline: SPLINE;
    constructor(data: KeyframeValues);
    private getValues;
    private getTimeIndex;
    private getEasing;
    private getSpline;
    get data(): (string | number)[];
}
export declare class Track {
    value: TrackValue;
    /**
     * Handler for the track property.
     * @param {TrackValue} value
     */
    constructor(value: TrackValue);
    /**
     * Safely check if either the array contains this value or the track is equal to this value.
     * @param {String} value
     * @returns
     */
    has(value: string): boolean;
}
/**
 * Specific function for animations, converts an array with a single element to be double nested.
 * @param {Array} array
 * @returns {Array}
 */
export declare function complexifyArray(array: KeyframesAny): KeyframeArray;
/**
 * Specific function for animations, converts a double nested array with a single element to an array with a single element.
 * @param {Array} array
 * @returns {Array}
 */
export declare function simplifyArray(array: KeyframesAny): KeyframesAny;
/**
 * Specific function for animations, removes similar keyframes from an animation.
 * @param {Array} animation
 * @param {Number} lenience The maximum distance values can be considered similar.
 * @returns {Array}
 */
export declare function optimizeArray(animation: KeyframesAny, lenience?: number): KeyframesAny;
/**
 * Specific function for animations, checks if an animation isn't double nested.
 * @param {Object} array
 * @returns {Boolean}
 */
export declare function isSimple(array: KeyframesAny): boolean;
/**
 * Get the values of an animation at a given time. Accounts for easings and splines!
 * @param {String} property
 * @param {Array} animation
 * @param {Time} time
 * @returns {Array}
 */
export declare function getValuesAtTime(property: string, animation: KeyframesAny, time: number): number[];
/**
 * Allows you to combine two animations together as long as atleast one of them has only a single keyframe.
 * @param {Array} anim1
 * @param {Array} anim2
 * @param {String} property Property that the animation originated from, important to determine how to combine.
 * @returns {Array}
 */
export declare function combineAnimations(anim1: KeyframesAny, anim2: KeyframesAny, property: string): KeyframesAny;
/**
 * Export keyframes to a point definition.
 * @param {Array} animation
 * @param {String} name
 */
export declare function toPointDef(animation: KeyframesAny, name: string): void;
