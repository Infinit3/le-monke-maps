"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GiveNotesOnLanesTrack = exports.GiveTypeNotesTrack = exports.GiveWallsTrack = exports.GiveNotesTrack = void 0;
const Remapper = __importStar(require("swifter_remapper"));
/**
 * Gives the notes between desired beats a track.
 * @param track The track you want the notes to have.
 * @param t1 From which beat it should start assigning the track.
 * @param t2 To which beat it should assign the tracks to.
 * @author StormPacer
 */
function GiveNotesTrack(track, t1, t2) {
    const filterednotes = Remapper.activeDiff.notes.filter(n => n.time >= t1 && n.time <= t2);
    filterednotes.forEach(note => {
        if (!note.customData._track)
            note.customData._track = track;
        if (Array.isArray(note.customData._track))
            note.customData._track.push(track);
        else if (note.customData._track != track)
            note.customData._track = [note.customData._track, track];
    });
}
exports.GiveNotesTrack = GiveNotesTrack;
/**
 * Gives the walls between desired beats a track.
 * @param track The track you want the walls to have.
 * @param t1 From which beat it should start assigning the track.
 * @param t2 To which beat it should assign the tracks to.
 * @author StormPacer
 */
function GiveWallsTrack(track, t1, t2) {
    const filteredwalls = Remapper.activeDiff.obstacles.filter(o => o.time >= t1 && o.time <= t2);
    filteredwalls.forEach(wall => {
        if (!wall.customData)
            wall.customData = {};
        if (Array.isArray(wall.customData._track))
            wall.customData._track.push(track);
        else
            wall.customData._track = track;
    });
}
exports.GiveWallsTrack = GiveWallsTrack;
/**
 * Gives the notes between desired beats a track. Separates by lanes
 * @param lane1Track The track you want the notes on lane 1 to have.
 * @param lane2Track The track you want the notes on lane 2 to have.
 * @param lane3Track The track you want the notes on lane 3 to have.
 * @param lane4Track The track you want the notes on lane 4 to have.
 * @param t1 From which beat it should start assigning the track.
 * @param t2 To which beat it should assign the tracks to.
 * @author StormPacer
 */
function GiveNotesOnLanesTrack(lane1Track, lane2Track, lane3Track, lane4Track, t1, t2) {
    const filterednotes = Remapper.activeDiff.notes.filter(n => n.time >= t1 && n.time <= t2);
    filterednotes.forEach(note => {
        if (note.json._lineLayer == 0) {
            if (!note.customData._track)
                note.customData._track = lane1Track;
            if (Array.isArray(note.customData._track))
                note.customData._track.push(lane1Track);
            else if (note.customData._track != lane1Track)
                note.customData._track = [note.customData._track, lane1Track];
        }
        if (note.json._lineLayer == 1) {
            if (!note.customData._track)
                note.customData._track = lane2Track;
            if (Array.isArray(note.customData._track))
                note.customData._track.push(lane2Track);
            else if (note.customData._track != lane2Track)
                note.customData._track = [note.customData._track, lane2Track];
        }
        if (note.json._lineLayer == 2) {
            if (!note.customData._track)
                note.customData._track = lane3Track;
            if (Array.isArray(note.customData._track))
                note.customData._track.push(lane3Track);
            else if (note.customData._track != lane3Track)
                note.customData._track = [note.customData._track, lane3Track];
        }
        if (note.json._lineLayer == 3) {
            if (!note.customData._track)
                note.customData._track = lane4Track;
            if (Array.isArray(note.customData._track))
                note.customData._track.push(lane4Track);
            else if (note.customData._track != lane4Track)
                note.customData._track = [note.customData._track, lane4Track];
        }
    });
}
exports.GiveNotesOnLanesTrack = GiveNotesOnLanesTrack;
/**
 * Gives the notes between desired beats a track. Separates by type
 * @param type0Track The track you want the left notes to have.
 * @param type1Track The track you want the right notes to have.
 * @param t1 From which beat it should start assigning the track.
 * @param t2 To which beat it should assign the tracks to.
 * @author StormPacer
 */
function GiveTypeNotesTrack(type0Track, type1Track, t1, t2) {
    const filterednotes = Remapper.activeDiff.notes.filter(n => n.time >= t1 && n.time <= t2);
    filterednotes.forEach(note => {
        if (note.type == 0) {
            if (!note.customData._track)
                note.customData._track = type0Track;
            if (Array.isArray(note.customData._track))
                note.customData._track.push(type0Track);
            else if (note.customData._track != type0Track)
                note.customData._track = [note.customData._track, type0Track];
        }
        if (note.type == 1) {
            if (!note.customData._track)
                note.customData._track = type1Track;
            if (Array.isArray(note.customData._track))
                note.customData._track.push(type1Track);
            else if (note.customData._track != type0Track)
                note.customData._track = [note.customData._track, type1Track];
        }
    });
}
exports.GiveTypeNotesTrack = GiveTypeNotesTrack;
