"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NoteTrailTrack = exports.NoteTrail = exports.NoteTrailType = void 0;
const Remapper = __importStar(require("swifter_remapper"));
const random_1 = require("../internal/random");
var NoteTrailType;
(function (NoteTrailType) {
    NoteTrailType["BLOCK"] = "block";
    NoteTrailType["ARROW"] = "arrow";
    NoteTrailType["BOTH"] = "both";
})(NoteTrailType || (NoteTrailType = {}));
exports.NoteTrailType = NoteTrailType;
function InternalNoteTrail(filterednotes, length = 5, type) {
    filterednotes.forEach(note => {
        note.noteGravity = false;
        note.noteLook = false;
        note.spawnEffect = false;
        for (let i = 1; i <= length; i++) {
            let dupe = new Remapper.Note(note.time, note.type, note.direction, note.position);
            dupe.noteGravity = false;
            dupe.noteLook = false;
            dupe.spawnEffect = false;
            dupe.fake = true;
            dupe.animation._position = [[(0, random_1.Random)(-0.2, 0.2), 0, i * 4, 0.4], [0, 0, 0, 0.7]];
            dupe.animation._localRotation = [[(0, random_1.Random)(0, 180), (0, random_1.Random)(0, 180), (0, random_1.Random)(0, 180), 0], [0, 0, 0, 0.3]];
            if (type.valueOf() == "note" || type.valueOf() == "both")
                dupe.animation._dissolve = [[0.1, 0], [0, 1, Remapper.EASE.IN_OUT_CUBIC]];
            if (type.valueOf() == "arrow" || type.valueOf() == "both")
                dupe.animation._dissolveArrow = [[0.1, 0]];
            dupe.push();
        }
    });
}
/**
 * Spawns a trail behind a note - similar to Somewhere Out There
 * @param startBeat The beat to start the effect on.
 * @param endBeat The beat to end the effect on.
 * @param length The length of the trail.
 * @param type What the effect should use for the trail, it can be "arrow" or "block"
 * @author cal117
 */
function NoteTrail(startBeat, endBeat, length = 5, type = NoteTrailType.ARROW) {
    const filterednotes = Remapper.activeDiff.notes.filter(note => note.time >= startBeat && note.time <= endBeat);
    InternalNoteTrail(filterednotes, length, type);
}
exports.NoteTrail = NoteTrail;
/**
 * Spawns a trail behind a note - similar to Somewhere Out There
 * @param track The track to apply the effect on.
 * @param length The length of the trail.
 * @param type What the effect should use for the trail, it can be "arrow" or "block"
 * @author cal117
 */
function NoteTrailTrack(track, length = 5, type = NoteTrailType.ARROW) {
    const filterednotes = Remapper.activeDiff.notes.filter(note => {
        if (!note.customData)
            note.customData = {};
        if (Array.isArray(note.customData._track))
            return note.customData._track.includes(track);
        else if (note.customData._track == track)
            return true;
        else
            return false;
    });
    InternalNoteTrail(filterednotes, length, type);
}
exports.NoteTrailTrack = NoteTrailTrack;
